"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.IPAddressBlocking = void 0;
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
class IPAddressBlocking {
    static resetState() {
        this.currentNetworkInterfaces = '';
        this.lastResultSuccess = false;
        this.lastEndpointQueryTime = 0;
    }
    static checkIP(apiServer, orgID) {
        return new Promise((resolve, reject) => {
            internal_1.chrome.system.network.getNetworkInterfaces(async (interfaces) => {
                // Check if the interface has changed at all since the last time
                try {
                    const checkObj = JSON.stringify(interfaces);
                    const currentTime = Date.now();
                    if (this.currentNetworkInterfaces !== checkObj) {
                        logger.logMessage('*** NETWORK interfaces: ' + checkObj);
                        // Interface has changed since we last checked so ask the web service if our IP is any good
                        this.currentNetworkInterfaces = checkObj;
                        this.lastResultSuccess =
                            await this.retrieveIsAllowedIP(apiServer, orgID);
                    }
                    else if (currentTime - this.lastEndpointQueryTime >
                        300000) {
                        // If we haven't checked in the last five minutes, force a check
                        logger.logMessage('IP allowed force check expiration');
                        this.lastResultSuccess =
                            await this.retrieveIsAllowedIP(apiServer, orgID);
                    }
                    else {
                        logger.logMessage('Network interfaces have not changed and not enough time elapsed for force check. Not doing online IP check.');
                    }
                }
                catch (err) {
                    this.lastResultSuccess = false;
                    logger.logError('checkIP exception: ' + err);
                }
                finally {
                    resolve(this.lastResultSuccess);
                }
            });
        });
    }
    static retrieveIsAllowedIP(apiServer, orgID) {
        if (!apiServer.endsWith('/'))
            apiServer += '/';
        return new Promise((resolve, reject) => {
            internal_1.routeVerifier.verify(apiServer +
                internal_1.Endpoints.IPCheckEndpoint.replace('${orgID}', orgID), async (url) => {
                var _a;
                this.lastEndpointQueryTime = Date.now();
                try {
                    const response = await internal_1.httpAPI.get(url);
                    if (((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.ipAllowed) === false) {
                        logger.logMessage('ipAllowed returned false');
                        reject();
                    }
                    else {
                        logger.logMessage("ipAllowed returned true or an unrecognized object. Let's continue...");
                        resolve(true);
                    }
                }
                catch (error) {
                    // If we got a 404 back or we get back a '0' (which can happen if the network is unreachable.)
                    // We'll assume we're OK but we want to recheck ASAP.
                    logger.logMessage("checkIPCall returned something unexpected. We'll continue anyway...");
                    this.lastEndpointQueryTime = 0; // Force a query next time we are run.
                    resolve(true);
                }
            });
        });
    }
}
exports.IPAddressBlocking = IPAddressBlocking;
IPAddressBlocking.currentNetworkInterfaces = '';
IPAddressBlocking.lastResultSuccess = false;
IPAddressBlocking.lastEndpointQueryTime = 0;
//# sourceMappingURL=ipAddressBlocking.js.map