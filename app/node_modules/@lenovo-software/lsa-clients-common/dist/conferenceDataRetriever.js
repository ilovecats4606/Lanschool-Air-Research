"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConferenceDataRetriever = void 0;
const internal_1 = require("./internal");
const defs_1 = require("./js/defs");
const logger = new internal_1.LoggerInterop();
class ConferenceDataRetriever {
    constructor(params) {
        this.apiServer = '';
        this.deviceId = '';
        this.provisioningCode = '';
        this.apiServer = params.apiServer;
        this.deviceId = params.deviceId;
        this.provisioningCode = params.provisioningCode;
    }
    getTokenExpiration(token) {
        const strSplit = token.split('.');
        if (!strSplit || strSplit.length !== 3) {
            throw new Error('Invalid token.');
        }
        const arrayBuffer = (0, internal_1.Base64ToArrayBufferEx)(strSplit[1]);
        const enc = new TextDecoder();
        const strObj = enc.decode(arrayBuffer);
        if (!strObj) {
            throw new Error('Malformed JWT payload.');
        }
        const tokenPayload = JSON.parse(strObj);
        if (!tokenPayload || !tokenPayload.hasOwnProperty('exp')) {
            throw new Error('Token missing expiration.');
        }
        return Number.parseInt(tokenPayload.exp) * 1000;
    }
    isTokenExpiredOrExpiring(token, minBufferInMS) {
        try {
            const s = this.getTokenExpiration(token);
            logger.logMessage('ConferenceDataRetriever.isTokenExpiredOrExpiring(): Token expires at ' + new Date(s));
            if (s < Date.now() + minBufferInMS)
                return true;
        }
        catch (e) {
            logger.logError('ConferenceDataRetriever.isTokenExpiredOrExpiring(): ' + e);
            return true;
        }
        return false;
    }
    needsNewToken(teacherData, isBroadcast) {
        var _a;
        if (!this.conferenceData.conferenceId && this.conferenceData.conferenceServerId === '') {
            logger.logMessage('ConferenceDataRetriever.needsNewToken(): conferenceData not set yet.');
            return true;
        }
        if (this.conferenceData.viewerConferenceToken === '' || this.conferenceData.broadcasterConferenceToken === '') {
            logger.logMessage('ConferenceDataRetriever.needsNewToken(): both conference tokens are not set yet.');
            return true;
        }
        if (this.conferenceData.conferenceId !== teacherData.conferenceId) {
            logger.logMessage('ConferenceDataRetriever.needsNewToken(): conferenceId differs.');
            return true;
        }
        if (teacherData.conferenceServerId !== this.conferenceData.conferenceServerId) {
            logger.logMessage('ConferenceDataRetriever.needsNewToken(): conferenceServerId differs.');
            return true;
        }
        const conferenceToken = (_a = (isBroadcast ? this.conferenceData.broadcasterConferenceToken : this.conferenceData.viewerConferenceToken)) !== null && _a !== void 0 ? _a : '';
        if (this.isTokenExpiredOrExpiring(conferenceToken, 300000)) {
            logger.logMessage('ConferenceDataRetriever.needsNewToken(): Token is expired or expiring soon...');
            return true;
        }
        return false;
    }
    async retrieveConferenceData(classId, isBroadcast) {
        if (!classId || classId.length === 0) {
            logger.logError('ConferenceDataRetriever.retrieveConferenceData: Invalid class Id');
            throw new Error('Invalid class Id');
        }
        if (!this.apiServer || this.apiServer.length === 0) {
            logger.logError('ConferenceDataRetriever.retrieveConferenceData: Missing API server');
            throw new Error('Missing API server');
        }
        if (!this.provisioningCode || this.provisioningCode.length === 0) {
            logger.logError('ConferenceDataRetriever.retrieveConferenceData: Missing provisioning code');
            throw new Error('Missing provisioning code');
        }
        let oauthToken = '';
        try {
            const authResponse = await internal_1.AccessToken.getAccessToken(this.apiServer, this.deviceId, this.provisioningCode);
            if (authResponse.access_token && authResponse.access_token.length > 0) {
                oauthToken = authResponse.access_token;
            }
            else {
                throw new Error('Auth token missing \'access_token\'');
            }
        }
        catch (err) {
            logger.logError('ConferenceDataRetriever.retrieveConferenceData: Error retrieving auth token: ' + err);
            throw err;
        }
        const endpoint = isBroadcast ? internal_1.Endpoints.BroadcasterTokenEndpoint : internal_1.Endpoints.ViewerTokenEndpoint;
        return new Promise((resolve, reject) => {
            internal_1.routeVerifier.verify(this.apiServer + endpoint, async (url) => {
                const body = {
                    classId: classId
                };
                logger.logMessage('ConferenceDataRetriever.retrieveConferenceData: Gathering... ' + url + ' with body: ' + JSON.stringify(body));
                try {
                    const response = await internal_1.httpAPI.post(url, JSON.stringify(body), oauthToken);
                    logger.logMessage('ConferenceDataRetriever.retrieveConferenceData: ' + response.status);
                    if ([200, 201].includes(response.status)) {
                        const conferenceData = await response.json();
                        logger.logMessage('ConferenceDataRetriever.retrieveConferenceData: Got conference data successfully.');
                        conferenceData.oauthToken = oauthToken;
                        resolve(conferenceData);
                    }
                    else {
                        const msg = 'post token returned something unexpected: ' + response.status;
                        logger.logMessage('ConferenceBroadcastDataRetriever._retrieveConferenceData(): ' + msg);
                        reject(new Error(msg));
                    }
                }
                catch (err) {
                    logger.logError('ConferenceDataRetriever.retrieveConferenceData: Error retrieving conference data: ' + err);
                    reject(err);
                }
            });
        });
    }
    async getConferenceData(teacherData, classId, conferenceType) {
        var _a, _b, _c, _d;
        var _e, _f;
        const isBroadcast = (conferenceType & defs_1.STUDENT_CONFERENCE_TYPE_VIDEO) === defs_1.STUDENT_CONFERENCE_TYPE_VIDEO;
        logger.logMessage('ConferenceDataRetriever.getConferenceData: isBroadcast => ' + isBroadcast);
        if (this.conferenceData && teacherData && !this.needsNewToken(teacherData, isBroadcast)) {
            logger.logMessage('ConferenceDataRetriever.retrieveConferenceData(): New conference token not needed.');
            return this.conferenceData;
        }
        try {
            const conferenceData = await this.retrieveConferenceData(classId, isBroadcast);
            const conferenceDataProp = Object.assign({}, conferenceData);
            /** NOTE: Save prev token for use in next switch to video/screen during same conference
             *
             * if changed from video to screen: assign prev viewer conference token
             * if changed from screen to video: assign prev broadcaster conference token
            */
            if (conferenceData.conferenceServerId === ((_a = this.conferenceData) === null || _a === void 0 ? void 0 : _a.conferenceServerId) && conferenceData.conferenceId === ((_b = this.conferenceData) === null || _b === void 0 ? void 0 : _b.conferenceId)) {
                if (isBroadcast) {
                    conferenceDataProp.viewerConferenceToken = (_c = (_e = this.conferenceData).viewerConferenceToken) !== null && _c !== void 0 ? _c : (_e.viewerConferenceToken = '');
                }
                else {
                    conferenceDataProp.broadcasterConferenceToken = (_d = (_f = this.conferenceData).broadcasterConferenceToken) !== null && _d !== void 0 ? _d : (_f.broadcasterConferenceToken = '');
                }
            }
            this.conferenceData = conferenceDataProp;
            return conferenceData;
        }
        catch (err) {
            logger.logError('ConferenceDataRetriever.getConferenceData: Error retrieving conference data: ' + err);
            throw err;
        }
    }
}
exports.ConferenceDataRetriever = ConferenceDataRetriever;
//# sourceMappingURL=conferenceDataRetriever.js.map