"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogExporter = void 0;
const internal_1 = require("./internal");
class LogExporter {
    constructor() {
        internal_1.logger.masterLogger = true;
        internal_1.logger.logToConsole = false;
    }
    static getInstance() {
        if (!LogExporter.instance) {
            LogExporter.instance = new LogExporter();
        }
        return LogExporter.instance;
    }
    logDebug(msg) {
        internal_1.logger.logDebug(msg);
    }
    logInfo(msg) {
        this.logMessage(msg);
    }
    logMessage(msg) {
        internal_1.logger.logMessage(msg);
    }
    logWarning(msg) {
        internal_1.logger.logWarning(msg);
    }
    logError(msg) {
        internal_1.logger.logError(msg);
    }
    async retrieveObfuscatedLogBufferWithHeader(header) {
        return this.retrieveObfuscatedBufferCommon(header);
    }
    async retrieveObfuscatedLogBuffer() {
        return this.retrieveObfuscatedBufferCommon(null);
    }
    retrieveLogBuffer() {
        return new Promise((resolve) => {
            const currentLog = new internal_1.LogClientEx(['default-rb', 'SIO']).getLogs();
            let responseArray = new Array();
            if (!currentLog ||
                !currentLog.logEntries ||
                !Array.isArray(currentLog.logEntries)) {
                resolve(responseArray);
                return;
            }
            for (let i = 0; i < currentLog.logEntries.length; i++) {
                let entryString = (currentLog.logEntries[i].date || 'NO DATE') +
                    ',' +
                    (currentLog.logEntries[i].severity || 'NO SEVERITY') +
                    ',' +
                    (currentLog.logEntries[i].entry || 'NO ENTRY') +
                    '\n';
                responseArray.push(entryString);
            }
            resolve(responseArray);
        });
    }
    async retrieveObfuscatedBufferCommon(header) {
        let logArray = await this.retrieveLogBuffer();
        let sHeader = "";
        if (header && header.length > 0) {
            sHeader = header.join('');
        }
        const responseString = sHeader + logArray.join('');
        const c = new internal_1.CryptoAsym();
        await c.initEncryptionKey();
        const cipherText = await c.encrypt(responseString, internal_1.LogEncryptPublicKey);
        return cipherText;
    }
}
exports.LogExporter = LogExporter;
//# sourceMappingURL=logExporter.js.map