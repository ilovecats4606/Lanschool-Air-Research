"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntelliTaskInfo = void 0;
const internal_1 = require("./internal");
const IntelliTaskInfoModel_1 = require("./models/IntelliTaskInfoModel");
const lodash_1 = require("lodash");
const CRC32C = __importStar(require("crc-32"));
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const platform_1 = require("./platform");
const lruCache_1 = require("./shared/lruCache");
// Request image in the original dimension by passing height and width value -1 in other words don't resize the image.
const DEFAULT_THUMBNAIL_WIDTH = 1920;
const DEFAULT_THUMBNAIL_HEIGHT = 1080;
const DEFAULT_THUMBNAIL_FORMAT = 'JPEG'; // will always be a jpeg from both platforms, no matter     what is specified
class IntelliTaskInfo {
    constructor(param) {
        /**
         * Fudge factor (250 ms) helps to address timing inaccuracies with the standard setInterval.
         * You can see that a similar fudge factor is being used for telemetry requests.
         */
        this.MAX_INTELLITASKINFO_SEND_FUDGE_FACTOR_MS = 250;
        this.messageSendIntelliTaskInfoPeriodMs = 0;
        this.overrideMessageSendIntelliTaskInfoPeriod = 0;
        this.lastIntelliTaskInfoSentTimeMs = 0;
        this.intelliTaskInfoPollingHandle = null;
        this.intelliTaskInfoSendingInProgress = false;
        this.isOtmResponseDue = false;
        this.assessmentResultsCache = new lruCache_1.LRUCache();
        this.thumbnailObj = null;
        this.metrics = new IntelliTaskMetrics();
        this.currentTabs = new internal_1.OtmCurrentTabsInterop();
        this.sioMsg = param.sioMsg;
        this.logger = new internal_1.LoggerInterop();
        this.initIntelliTaskInfoParams();
        this.intellitaskAssessmentSubscription = pubsub_js_1.default.subscribe('onIntelliTaskAssessmentReceived', (msg, data) => this.handleIntelliTaskAssessmentMsg(data));
        this.reqNewAssessmentSubscription = pubsub_js_1.default.subscribe('onRequestNewIntelliTaskAssessment', (msg, data) => this.handleReqNewIntelliTaskAssessmentMsg(data));
    }
    handleIntelliTaskAssessmentMsg(intelliTaskAssessment) {
        this.isOtmResponseDue = false;
        this.assessmentResultsCache.set(intelliTaskAssessment.tabsInfoChecksum, intelliTaskAssessment);
        this.logger.logMessage('IntelliTask assessment is cached. Cache key: ' + intelliTaskAssessment.tabsInfoChecksum);
    }
    handleReqNewIntelliTaskAssessmentMsg(message) {
        if (message.requestNewIntelliTaskAssessment.reason === 'objective_update') {
            this.isOtmResponseDue = false;
            this.assessmentResultsCache.clear();
            this.logger.logDebug('Assessment results cache is cleared.');
        }
        // Clear last saved tab state so that it'll send a new message though tab state is not changed.
        this.lastTabState = {};
        this.sendIntelliTaskInfo();
    }
    initIntelliTaskInfoParams() {
        this.messageSendIntelliTaskInfoPeriodMs = 0;
        this.lastIntelliTaskInfoSentTimeMs = 0;
    }
    /**
     * It is possible for students to have a browser open, but no actual websites.
     * They could have only 'chrome://' tabs.
     *
     * If the active tab has a url such as 'chrome://' we get flag 'activeTabInfo.valid' to false
     * from the extension. Also, if all tabs contain invalid urls we get an empty tabs array.
     * So, if these two conditions are met we can say that all browser tabs contain non website urls.
     */
    areAllOpenTabsNonWebsite() {
        var _a, _b, _c;
        const activeTabInfo = (_b = (_a = this.currentTabs) === null || _a === void 0 ? void 0 : _a.otmBrowserTabs) === null || _b === void 0 ? void 0 : _b.activeTabInfo;
        return (!(activeTabInfo === null || activeTabInfo === void 0 ? void 0 : activeTabInfo.valid) && ((_c = this.tabsInfo) === null || _c === void 0 ? void 0 : _c.length) === 0);
    }
    getMessage() {
        var _a, _b, _c, _d, _e, _f, _g;
        const storage = internal_1.LSAClient.getInstance().storage;
        const classChannel = internal_1.LSAClient.getInstance().getClassChannel();
        const intelliTaskMessage = {
            type: 'intelliTaskMessage',
            tabsInfo: this.tabsInfo,
            allOpenTabsAreNonWebsite: this.areAllOpenTabsNonWebsite(),
            tabsInfoChecksum: this.tabsInfoChecksum,
            // for a metrics report, we won't need the image, as the OTM session has actually ended
            image: this.metrics.isReportReady ? null : this.thumbnailObj,
            isCompressed: false,
            timestamp: this.logger.timeStampMS(true),
            loginName: (_a = storage === null || storage === void 0 ? void 0 : storage.loadEmailAddr()) !== null && _a !== void 0 ? _a : '',
            studentId: (_c = (_b = storage === null || storage === void 0 ? void 0 : storage.loadProvisioningData()) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '',
            studentName: (_d = storage === null || storage === void 0 ? void 0 : storage.loadDisplayName()) !== null && _d !== void 0 ? _d : '',
            machineName: (_e = storage === null || storage === void 0 ? void 0 : storage.loadDeviceName()) !== null && _e !== void 0 ? _e : '',
            deviceId: (_f = storage === null || storage === void 0 ? void 0 : storage.loadDeviceId()) !== null && _f !== void 0 ? _f : '(unknown)',
            // active class related info
            classId: classChannel === null || classChannel === void 0 ? void 0 : classChannel.getClassID(),
            activeClassSessionId: classChannel === null || classChannel === void 0 ? void 0 : classChannel.getActiveClassID(),
            captureMode: internal_1.store.getState().captureMode,
            platform: new platform_1.PlatformParser(storage === null || storage === void 0 ? void 0 : storage.loadOsString()).getPlatform(),
            isWebExtensionAvailable: !!((_g = internal_1.store.getState().webExtension) === null || _g === void 0 ? void 0 : _g.isConnected)
        };
        if (this.metrics.isReportReady) {
            intelliTaskMessage.metrics = JSON.stringify(this.metrics.generateReport());
        }
        return [
            { name: 'type', value: 'intelliTaskMessage' },
            { name: 'intelliTaskMessage', value: intelliTaskMessage },
        ];
    }
    shouldSendIntelliTaskInfo(param) {
        if (this.intelliTaskInfoSendingInProgress) {
            return false;
        }
        if (param && param.purpose === 'New Telemetry Request') {
            this.logger.logMessage('Forcing IntelliTaskInfo to be sent.');
            return true;
        }
        const now = Date.now();
        const expectedNextRequestTimeMs = this.lastIntelliTaskInfoSentTimeMs + this.messageSendIntelliTaskInfoPeriodMs - this.MAX_INTELLITASKINFO_SEND_FUDGE_FACTOR_MS;
        if (now < expectedNextRequestTimeMs) {
            const timeDiff = now - this.lastIntelliTaskInfoSentTimeMs;
            this.logger.logDebug('Not sending IntelliTaskInfo because IntelliTaskInfo already sent within ' +
                this.messageSendIntelliTaskInfoPeriodMs +
                'ms ago: ' +
                timeDiff);
            return false;
        }
        this.logger.logDebug(`IntelliTaskInfo last sent ${(now - this.lastIntelliTaskInfoSentTimeMs)} ms ago.`);
        // Skip sending message if the OTM response is not received yet for the last message
        // It is still possible that there was a communication issue and that's why response is not received for the last message.
        // So don't block sending messages indefinitely. Note - multiplication factor (4) used here is not derived from any formula.
        // This value can be changed to increase or decrease delay in max wait time for OTM responses.
        const maxTimeThatWeCanWaitForOtmResponse = expectedNextRequestTimeMs + 4 * this.messageSendIntelliTaskInfoPeriodMs;
        if (this.isOtmResponseDue && maxTimeThatWeCanWaitForOtmResponse > now) {
            this.logger.logDebug('Not sending IntelliTaskInfo because the OTM response is not received yet for the last message.');
            return false;
        }
        return true;
    }
    stopIntelliTaskInfoPolling() {
        clearTimeout(this.intelliTaskInfoPollingHandle);
        this.intelliTaskInfoPollingHandle = null;
    }
    callIntelliTaskInfoAgainLater(param) {
        this.stopIntelliTaskInfoPolling();
        if (this.messageSendIntelliTaskInfoPeriodMs <= 0)
            return;
        this.intelliTaskInfoPollingHandle = setTimeout(async () => {
            await this.sendIntelliTaskInfo(param);
        }, this.overrideMessageSendIntelliTaskInfoPeriod || this.messageSendIntelliTaskInfoPeriodMs);
    }
    isThumbnailOK(image) {
        if (image === null || image === void 0 ? void 0 : image.size) {
            // FIXME - windows thumbnail generator exe is returing height and width -1,
            // after building new exe following code can be removed.
            if (image.size.width === -1 && image.size.height === -1) {
                return true;
            }
            // Image has valid dimensions - nonzero width and height.
            return image.size.width > 0 && image.size.height > 0;
        }
        return false;
    }
    /*
    Gets a large screenshot for Intellitask.  However, if the size is over 750,000KB, we will try again at a lower size
    This is due to the Kafka max message size of 1MB per message
     */
    async getLargeScreenshot(params) {
        const instrumentation = internal_1.LSAClient.getInstance().otmScreenCapture || internal_1.LSAClient.getInstance().telemetryInstrumentation.screenCapture;
        if (instrumentation) {
            const thumbnailRequest = internal_1.ScreenCaptureInterop.translateThumbnailParamsToThumbnailRequest(params);
            const image = await instrumentation.getThumbnail(thumbnailRequest);
            if (params.maxBase64 && image.image.length > params.maxBase64) {
                params.height = Math.round(params.height * .8);
                params.width = Math.round(params.width * .8);
                params.skipResize = false; // Allow scaling of image
                this.logger.logMessage(`Intellitask image was too large (${image.image.length}), trying again with lower resolution (${params.width}x${params.height})`);
                return await this.getLargeScreenshot(params);
            }
            else {
                return internal_1.ScreenCaptureInterop.translateThumbnailImageToJS(image);
            }
        }
    }
    async sendIntelliTaskInfo(param) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.stopIntelliTaskInfoPolling();
        if (!this.shouldSendIntelliTaskInfo(param)) {
            this.callIntelliTaskInfoAgainLater();
            return;
        }
        this.intelliTaskInfoSendingInProgress = true;
        this.logger.logMessage('sendIntelliTaskInfo (+)');
        let isContentCaptured = false;
        let tabStateIsChanged = true;
        const startCaptureTime = Date.now();
        await this.currentTabs.callInstrumentation();
        const tabInfoWasSent = !!this.tabsInfo;
        this.tabsInfo = [];
        // if there is no extension, tabs array will be empty
        const otmTabs = (_a = this.currentTabs.otmBrowserTabs.tabs) !== null && _a !== void 0 ? _a : [];
        otmTabs.map((tab) => {
            var _a;
            const tabInfo = (0, lodash_1.pick)(tab, ['title', 'url', 'audioElements', 'audible', 'muted', 'usedDataGathering']);
            tabInfo.isActive = (_a = (tab.isActive || tab.lastFocused)) !== null && _a !== void 0 ? _a : false;
            // content will not be present if full sentences were not found or if there were extraction errors
            if (tab.content && tab.content.length > 0) {
                isContentCaptured = true;
                tabInfo.content = tab.content;
            }
            if (this.isValidTab(tabInfo)) {
                this.tabsInfo.push(tabInfo);
            }
        });
        const newTabState = IntelliTaskInfoModel_1.LastIntellitaskMessageState.from(this.currentTabs.otmBrowserTabs);
        if (tabInfoWasSent && !this.hasTabStateChanged(newTabState)) {
            tabStateIsChanged = false;
            this.logger.logMessage('sendIntelliTaskInfo: Tab state has not changed, so this message will be skipped');
            this.metrics.notSent++;
        }
        this.lastTabState = newTabState;
        // update maxWindows property so we can keep track of how many Browser windows clients are running
        this.metrics.maxWindows = Math.max(this.metrics.maxWindows, new Set(otmTabs.map(tab => tab.windowId)).size);
        if (tabStateIsChanged) {
            // Check if there is any cached Intellitask assessment for current tab state
            this.tabsInfoChecksum = this.getTabsStateChecksum(this.lastTabState);
            if (this.assessmentResultsCache.has(this.tabsInfoChecksum)) {
                this.isOtmResponseDue = false;
                this.logger.logMessage('Cached assessment found for current tab state');
                // Send cached assessment to teacher
                const assessment = this.assessmentResultsCache.get(this.tabsInfoChecksum);
                if (assessment !== undefined) {
                    (_b = this.sioMsg) === null || _b === void 0 ? void 0 : _b.postIntellitaskAssesmentMessage(assessment);
                }
                this.metrics.cachedSent++;
            }
            else {
                // If tab state has changed and we do not have cached assessment for current tab state
                // send message to intelliTask for re-assessment
                const activeTabInfo = (_d = (_c = this.currentTabs) === null || _c === void 0 ? void 0 : _c.otmBrowserTabs) === null || _d === void 0 ? void 0 : _d.activeTabInfo;
                // Just make a note of text extraction errors, still allow sending current intellitask message
                if (activeTabInfo === null || activeTabInfo === void 0 ? void 0 : activeTabInfo.textExtractionError) {
                    this.metrics.addError(activeTabInfo === null || activeTabInfo === void 0 ? void 0 : activeTabInfo.textExtractionError);
                }
                if ((activeTabInfo === null || activeTabInfo === void 0 ? void 0 : activeTabInfo.valid) && // Active tab has valid url. URLs such as chrome:// are invalid
                    ((_e = this.tabsInfo) === null || _e === void 0 ? void 0 : _e.length) >= 1 && // There are one or more than one tabs
                    // Send a screenshot always when data gathering enabled site is loaded in the current active tab
                    ((activeTabInfo === null || activeTabInfo === void 0 ? void 0 : activeTabInfo.usedDataGathering) ||
                        // Do not send screenshot when special site is loaded except special site allows screenshot capture
                        // Do not send screenshot when page contents are captured
                        !isContentCaptured && (!(activeTabInfo === null || activeTabInfo === void 0 ? void 0 : activeTabInfo.isSpecialSite) || ((_f = activeTabInfo === null || activeTabInfo === void 0 ? void 0 : activeTabInfo.specialSite) === null || _f === void 0 ? void 0 : _f.screenshotAllowed)))) {
                    const thumbnailParams = {
                        width: DEFAULT_THUMBNAIL_WIDTH,
                        height: DEFAULT_THUMBNAIL_HEIGHT,
                        format: [DEFAULT_THUMBNAIL_FORMAT],
                        source: internal_1.store.getState().captureMode,
                        // Maximum size of image thumbnail 750,000KB, the limit is imposed due to kakfa messge size limit that is 1MB
                        maxBase64: 750000,
                        skipResize: true
                    };
                    let screenShot;
                    try {
                        screenShot = await this.getLargeScreenshot(thumbnailParams);
                    }
                    catch (err) {
                        this.logger.logError('Error gathering screenshot:' + err);
                    }
                    if (screenShot && this.isThumbnailOK(screenShot)) {
                        this.thumbnailObj = screenShot;
                        this.overrideMessageSendIntelliTaskInfoPeriod = 0;
                    }
                    else {
                        // since we failed to grab the screenshot, lets reduce our OTM interval to relieve potential backpressure issues and see if the issue otherwise resolves
                        this.overrideMessageSendIntelliTaskInfoPeriod = 30 * 1000;
                    }
                }
                else {
                    this.thumbnailObj = null;
                }
                this.lastIntelliTaskInfoSentTimeMs = Date.now();
                this.isOtmResponseDue = true;
                (_g = this.sioMsg) === null || _g === void 0 ? void 0 : _g.postMessageFromFactory(this);
                this.metrics.sent++;
                const endCaptureTime = Date.now();
                this.metrics.addResponseTimeMetric(endCaptureTime - startCaptureTime);
            }
        }
        this.intelliTaskInfoSendingInProgress = false;
        this.callIntelliTaskInfoAgainLater();
    }
    hasTabStateChanged(newTabState) {
        var _a;
        return JSON.stringify(newTabState) !== JSON.stringify((_a = this.lastTabState) !== null && _a !== void 0 ? _a : {});
    }
    isValidTab(tab) {
        if (!(tab === null || tab === void 0 ? void 0 : tab.title) || tab.title.length === 0 || !(tab === null || tab === void 0 ? void 0 : tab.url) || tab.url.length === 0) {
            return false;
        }
        try {
            // Chrome tabs like extensions, new tab with empty url are not valid tabs
            const url = new URL(tab === null || tab === void 0 ? void 0 : tab.url);
            return url.protocol.toLowerCase().indexOf('chrome') !== 0;
        }
        catch (error) {
            this.logger.logError('isValidTab exception:' + error);
            return false;
        }
    }
    doCleanup() {
        this.stopIntelliTaskInfoPolling();
        pubsub_js_1.default.unsubscribe(this.intellitaskAssessmentSubscription);
        pubsub_js_1.default.unsubscribe(this.reqNewAssessmentSubscription);
    }
    sendIntellitaskMetrics() {
        var _a;
        this.metrics.isReportReady = true;
        (_a = this.sioMsg) === null || _a === void 0 ? void 0 : _a.postMessageFromFactory(this);
    }
    getTabsStateChecksum(lastState) {
        const checksum = CRC32C.str(JSON.stringify(lastState));
        // checksum >>> 0: checksum is treated as an unsigned 32-bit integer
        // padStart(8, '0'): hexadecimal string is exactly 8 characters long by padding it with leading zeros if necessary 
        const checksumHex = (checksum >>> 0).toString(16).padStart(8, '0');
        return checksumHex;
    }
}
exports.IntelliTaskInfo = IntelliTaskInfo;
class IntelliTaskMetrics {
    constructor() {
        this.notSent = 0;
        this.sent = 0;
        this.cachedSent = 0;
        this.maxWindows = 1;
        this.isReportReady = false;
        this.responseTimeMetrics = [];
        this.errors = new Set();
    }
    generateReport() {
        return {
            sent: this.sent,
            notSent: this.notSent,
            cachedSent: this.cachedSent,
            maxWindows: this.maxWindows,
            maxResponseTime: (0, lodash_1.max)(this.responseTimeMetrics),
            avgResponseTime: (0, lodash_1.mean)(this.responseTimeMetrics),
            clientType: internal_1.Utils.isElectron() ? 'electron' : 'chrome',
            errors: Array.from(this.errors)
        };
    }
    addResponseTimeMetric(responseTime) {
        this.responseTimeMetrics.push(responseTime);
    }
    addError(error) {
        // Limit number of errors that we can cache in the memory
        const errorCacheSize = 100;
        if (this.errors.size < errorCacheSize) {
            this.errors.add(error);
        }
    }
}
//# sourceMappingURL=intelliTaskInfo.js.map