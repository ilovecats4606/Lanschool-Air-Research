"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.StudentStatusModel = exports.StudentStatusDetailMessage = exports.StudentStatusDetailType = exports.ConnectivityStatus = exports.StatusLightColor = void 0;
const internal_1 = require("../internal");
var StatusLightColor;
(function (StatusLightColor) {
    StatusLightColor["Red"] = "Red";
    StatusLightColor["Amber"] = "Amber";
    StatusLightColor["Green"] = "Green";
})(StatusLightColor = exports.StatusLightColor || (exports.StatusLightColor = {}));
var ConnectivityStatus;
(function (ConnectivityStatus) {
    ConnectivityStatus["Connected"] = "Connected";
    ConnectivityStatus["Disconnected"] = "Disconnected";
    ConnectivityStatus["Trying"] = "Trying";
})(ConnectivityStatus = exports.ConnectivityStatus || (exports.ConnectivityStatus = {}));
var StudentStatusDetailType;
(function (StudentStatusDetailType) {
    StudentStatusDetailType["Provisioning"] = "Provisioning";
    StudentStatusDetailType["TokenValidity"] = "TokenValidity";
    StudentStatusDetailType["Connectivity"] = "Connectivity";
})(StudentStatusDetailType = exports.StudentStatusDetailType || (exports.StudentStatusDetailType = {}));
class StudentStatusDetailMessage {
}
exports.StudentStatusDetailMessage = StudentStatusDetailMessage;
class StudentStatusModel {
    constructor() {
        this.ledColor = StatusLightColor.Red;
        this.messages = new Array();
        this.lastError = '';
    }
    static findDetailMessageInDataArray(detailType, data) {
        if (!data) {
            throw new Error('StudentStatusModel.findDetailMessageInDataArray(): No data');
        }
        if (!data.messages) {
            return null;
        }
        for (let i = 0; i < data.messages.length; i++) {
            if (data.messages[i].detailType === detailType) {
                return data.messages[i];
            }
        }
    }
    getProvisioningMessage(data) {
        const dataMessage = StudentStatusModel.findDetailMessageInDataArray(StudentStatusDetailType.Provisioning, data);
        let msg = new StudentStatusDetailMessage();
        msg.detailType = StudentStatusDetailType.Provisioning;
        msg.iconColor = (dataMessage === null || dataMessage === void 0 ? void 0 : dataMessage.iconColor) || StatusLightColor.Red;
        msg.localizedMessage = (dataMessage === null || dataMessage === void 0 ? void 0 : dataMessage.localizedMessage) || internal_1.chrome.i18n.getMessage('device_not_provisioned');
        return msg;
    }
    getTokenValidityMessage(data) {
        const dataMessage = StudentStatusModel.findDetailMessageInDataArray(StudentStatusDetailType.TokenValidity, data);
        let msg = new StudentStatusDetailMessage();
        msg.detailType = StudentStatusDetailType.TokenValidity;
        msg.iconColor = (dataMessage === null || dataMessage === void 0 ? void 0 : dataMessage.iconColor) || StatusLightColor.Red;
        msg.localizedMessage = (dataMessage === null || dataMessage === void 0 ? void 0 : dataMessage.localizedMessage) || internal_1.chrome.i18n.getMessage('no_valid_token');
        return msg;
    }
    getConnectivityMessage(data) {
        const dataMessage = StudentStatusModel.findDetailMessageInDataArray(StudentStatusDetailType.Connectivity, data);
        let msg = new StudentStatusDetailMessage();
        msg.detailType = StudentStatusDetailType.Connectivity;
        msg.iconColor = (dataMessage === null || dataMessage === void 0 ? void 0 : dataMessage.iconColor) || StatusLightColor.Red;
        msg.localizedMessage = (dataMessage === null || dataMessage === void 0 ? void 0 : dataMessage.localizedMessage) || internal_1.chrome.i18n.getMessage('not_connected_to_server');
        return msg;
    }
    static getInstance() {
        return StudentStatusModel.fromAny({});
    }
    static fromAny(data) {
        const ret = new StudentStatusModel();
        // Determine the correct status from the current message received.
        // This will be passed to the client to display in their own window.
        // This model will be used both for messages sent from the system when there is a
        // status update, as well as when a client queries for the current state. That query
        // should be a method inside lsaClient to retrieve the current status.
        ret.ledColor = data.ledColor || StatusLightColor.Red;
        ret.messages = new Array();
        ret.messages.push(ret.getProvisioningMessage(data));
        ret.messages.push(ret.getTokenValidityMessage(data));
        ret.messages.push(ret.getConnectivityMessage(data));
        if (data.lastError && data.lastError.length > 0) {
            ret.lastError = data.lastError;
        }
        return ret;
    }
}
exports.StudentStatusModel = StudentStatusModel;
//# sourceMappingURL=studentStatusModels.js.map