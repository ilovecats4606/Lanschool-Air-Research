"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageVerification = void 0;
const defs_1 = require("./js/defs");
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
class MessageVerification {
    constructor(messageExpiration, queueRetryTimeoutInterval) {
        this.publicKeys = [];
        this.recvQueue = [];
        this.enforceSigning = defs_1.SigningRequirementEnum.Unknown;
        this.queueRetryTimeout = 500;
        this.messageExpiration = 5000;
        if (queueRetryTimeoutInterval) {
            this.queueRetryTimeout = queueRetryTimeoutInterval;
        }
        if (messageExpiration) {
            this.messageExpiration = messageExpiration;
        }
    }
    reset() {
        this.publicKeys = [];
        this.recvQueue = [];
    }
    setSigningRequirements(signingRequirement) {
        this.enforceSigning = signingRequirement;
    }
    getSigningRequirements() {
        return this.enforceSigning;
    }
    isKeySame(key1, key2) {
        if (key1.hasOwnProperty('n') && key2.hasOwnProperty('n')) {
            return key1.n === key2.n;
        }
        else {
            throw new Error('MessageVerification.isKeySame(): One or more keys do not contain required properties.');
        }
    }
    includesPublicKey(publicKeyCandidate) {
        for (let i = 0; i < this.publicKeys.length; i++) {
            if (this.isKeySame(publicKeyCandidate, this.publicKeys[i].candidate)) {
                return true;
            }
        }
        return false;
    }
    async addPublicKey(publicKeyCandidate) {
        let self = this;
        if (!this.includesPublicKey(publicKeyCandidate)) {
            try {
                const publicKey = await internal_1.window.crypto.subtle.importKey('jwk', publicKeyCandidate, { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-256' } }, true, ['verify']);
                self.publicKeys.push({
                    publicKey: publicKey,
                    candidate: publicKeyCandidate
                });
                self.dequeueWaitingMessages();
            }
            catch (err) {
                logger.logError("Error importing teacher's public key: " + err);
            }
        }
        else {
            logger.logMessage('Public key already added.');
        }
    }
    extractPayloadFromSignedPayload(toExtract) {
        var _a;
        if ((_a = toExtract === null || toExtract === void 0 ? void 0 : toExtract.data) === null || _a === void 0 ? void 0 : _a.payload) {
            return toExtract.data.payload;
        }
        if (toExtract === null || toExtract === void 0 ? void 0 : toExtract.data) {
            return toExtract.data;
        }
        if (toExtract === null || toExtract === void 0 ? void 0 : toExtract.payload) {
            return toExtract.payload;
        }
        return toExtract;
    }
    async verifyMessageWithExpiration(data, expireTime) {
        var _a;
        let payload = this.extractPayloadFromSignedPayload(data);
        if (this.enforceSigning === defs_1.SigningRequirementEnum.None) {
            return Promise.resolve({
                verified: true,
                payload: payload
            });
        }
        if (this.enforceSigning === defs_1.SigningRequirementEnum.Unknown) {
            logger.logWarning('Signing requirement is unknown. Queuing message: ' +
                JSON.stringify(data));
            return Promise.resolve({
                verified: false,
                expireTime: expireTime,
                payload: payload
            });
        }
        if (this.publicKeys.length === 0) {
            logger.logWarning('Doing message verification but key array is empty. Queuing message: ' +
                JSON.stringify(data));
            return Promise.resolve({
                verified: false,
                expireTime: expireTime,
                payload: payload
            });
        }
        if (!(data === null || data === void 0 ? void 0 : data.signed) || ((_a = data === null || data === void 0 ? void 0 : data.signed) === null || _a === void 0 ? void 0 : _a.length) === 0) {
            logger.logError('Teacher message signature is missing.');
            return Promise.resolve({
                verified: false,
                expireTime: 0,
                payload: payload
            }); // Immediate failure
        }
        let abSignature = (0, internal_1.Base64ToArrayBufferEx)(data.signed);
        let abPayload = internal_1.PKI.str2ab(JSON.stringify(payload));
        let verified = false;
        let failures = 0;
        logger.logMessage('Checking teacher message verification against ' +
            this.publicKeys.length +
            ' keys.');
        for (let i = 0; i < this.publicKeys.length && !verified; i++) {
            try {
                const verified = await internal_1.window.crypto.subtle.verify('RSASSA-PKCS1-v1_5', this.publicKeys[i].publicKey, abSignature, abPayload);
                if (verified) {
                    return Promise.resolve({
                        verified: true,
                        expireTime: expireTime,
                        payload: payload
                    });
                }
                else {
                    failures++;
                    if (failures >= this.publicKeys.length) {
                        logger.logMessage('verifyTeacherMessage(): Payload verification failed for all keys.');
                        return Promise.resolve({
                            verified: false,
                            expireTime: expireTime,
                            payload: payload
                        });
                    }
                }
            }
            catch (err) {
                // Something went wrong with the verify. Could be malformed key. This does *not* happen if verification does not pass.
                logger.logError('Caught verification error: ' + err);
                return Promise.reject(err);
            }
        }
    }
    queueMessageForRetry(data, currentExpireTime, callback) {
        if (currentExpireTime === Number.MAX_SAFE_INTEGER) {
            currentExpireTime = Date.now() + this.messageExpiration;
        }
        this.recvQueue.push({
            data: data,
            callback: callback,
            expireTime: currentExpireTime
        });
    }
    queueMessageForVerification(data, callback) {
        this.recvQueue.push({
            data: data,
            callback: callback,
            expireTime: Number.MAX_SAFE_INTEGER
        });
    }
    async dequeueWaitingMessages() {
        logger.logMessage('MessageVerification.dequeueWaitingMessages(): Queue length is ' +
            this.recvQueue.length);
        while (this.recvQueue.length > 0) {
            const dequeued = this.recvQueue.shift();
            logger.logMessage('Queue Entry expireTime: ' + (dequeued === null || dequeued === void 0 ? void 0 : dequeued.expireTime));
            if (!dequeued)
                break;
            try {
                const resp = await this.verifyMessageWithExpiration(dequeued.data, dequeued.expireTime);
                const messageVerifiedResponse = resp;
                if (messageVerifiedResponse.verified) {
                    dequeued === null || dequeued === void 0 ? void 0 : dequeued.callback(messageVerifiedResponse.verified, messageVerifiedResponse.payload);
                }
                else {
                    if ((messageVerifiedResponse === null || messageVerifiedResponse === void 0 ? void 0 : messageVerifiedResponse.expireTime) &&
                        Date.now() > messageVerifiedResponse.expireTime) {
                        // This message legitimately did not verify because the key never showed up and we're done waiting.
                        logger.logMessage('Expiring message (' +
                            messageVerifiedResponse.expireTime +
                            '): ' +
                            JSON.stringify(messageVerifiedResponse.payload));
                        dequeued.callback(false, messageVerifiedResponse.payload);
                    }
                    else {
                        // If any changes since the while conditional (non-retry queue or added public key) go ahead and do another dequeue
                        setTimeout(async () => {
                            this.queueMessageForRetry(dequeued.data, dequeued.expireTime, dequeued.callback);
                            await this.dequeueWaitingMessages();
                        }, this.queueRetryTimeout);
                    }
                }
            }
            catch (err) {
                logger.logError('dequeueWaitingMessages exception: ' + err);
                const error = err;
                throw new Error(error);
            }
        }
    }
    async verifyMessage(data, callback) {
        this.queueMessageForVerification(data, callback);
        await this.dequeueWaitingMessages();
    }
}
exports.MessageVerification = MessageVerification;
//# sourceMappingURL=messageVerification.js.map