"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultOrgCheck = void 0;
require("isomorphic-fetch");
const internal_1 = require("../internal");
class DefaultOrgCheck {
    constructor() {
        this.waitTimeUntilNextCall = 0;
        this.client = internal_1.LSAClient.getInstance();
        this.init();
    }
    init() {
        this.waitTimeUntilNextCall = 0;
    }
    async provisioningCodeFromHotProvisioningCode(params) {
        var _a;
        // "${host}/0/lsa/lanschool/clients/provision/${code}/orgProvisionCode"
        /*
            {
                "orgProvisionCode": "c24d21a2-cca4-4102-8e7c-774044173e7e",
                "hotProvisioningEnds": "2021-11-17T17:07:03.941Z",
                "orgProvisioningEnds": "2021-12-31T07:00:00.000Z"
            }
        */
        if (!params.hotProvisioningCode ||
            params.hotProvisioningCode.length < 1) {
            return Promise.resolve(params.provisioningCode);
        }
        try {
            const url = params.apiServerForHTTPS +
                internal_1.Endpoints.HotProvisionExchange.replace('${hotProvisioningCode}', params.hotProvisioningCode);
            const response = await fetch(url, internal_1.httpAPI.getFetchHeaderObj('GET'));
            const status = await response.status;
            this.client.logger.logDebug('LSAClient.provisioningCodeFromHotProvisioningCode(): ' +
                'API returned status ' +
                status);
            const data = await response.json();
            if (((_a = data === null || data === void 0 ? void 0 : data.orgProvisionCode) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return Promise.resolve(data.orgProvisionCode);
            }
            else {
                return Promise.reject('No orgProvisioningCode returned from API');
            }
        }
        catch (e) {
            const error = 'Error exchanging hot provisioning code for permanent provisioning code: ' +
                e;
            this.client.logger.logError('LSAClient.provisioningCodeFromHotProvisioningCode(): ' + error);
            return Promise.reject(error);
        }
    }
    /**
     * Formulates the org check URL, calls it and returns the result.
     *
     * @param params instance of LSAClientParams which should have the API server and provisioning code
     * @returns an HTTP status and reason (if available) inside an OrgCheckEndpointResult interface
     */
    async getOrgCheckEndpointResult(params) {
        const orgCheckEndpoint = params.apiServerForHTTPS +
            internal_1.Endpoints.OrgCheckEndpoint +
            params.provisioningCode;
        this.client.logger.logDebug('DefaultOrgCheck.getOrgCheckEndpointResult(): Checking org at ' +
            orgCheckEndpoint);
        const response = await fetch(orgCheckEndpoint, internal_1.httpAPI.getFetchHeaderObj('GET'));
        let status = await response.status;
        this.client.logger.logInfo('DefaultOrgCheck.getOrgCheckEndpointResult(): Org check returned status: ' +
            status);
        // Prepare a default reason
        let responseJson = {
            reason: ''
        };
        try {
            responseJson = await response.json();
            this.client.logger.logInfo('DefaultOrgCheck.getOrgCheckEndpointResult(): Org check returned JSON: ' +
                JSON.stringify(responseJson));
        }
        catch (e) {
            this.client.logger.logMessage('DefaultOrgCheck.getOrgCheckEndpointResult(): No valid JSON: ' +
                e);
        }
        return {
            status,
            reason: responseJson === null || responseJson === void 0 ? void 0 : responseJson.reason
        };
    }
    /**
     * Returns true if an org is defined to be invalid. If this returns false, it doesn't mean the org is valid,
     * but it does at least mean it didn't meet the criteria to make a determination (yet.) An example of false
     * is a status of 404 but the reason is empty or there was some kind of gateway problem.
     *
     * @param orgCheckResponse
     * @returns
     */
    static orgCheckResponseIndicatesOrgIsDefinitelyInvalid(orgCheckResponse) {
        return ((orgCheckResponse.status === 404 ||
            orgCheckResponse.status === 403) &&
            (orgCheckResponse.reason === 'resourceNotFound' ||
                orgCheckResponse.reason === 'orgArchived' ||
                orgCheckResponse.reason === 'expiredLicenses'));
    }
    /**
     * Returns true if the org is acceptable. If this returns false, it doesn't mean the org is invalid,
     * but it does at least mean it didn't meet the criteria to make a determination (yet.)
     * @param orgCheckResponse
     * @returns
     */
    static orgCheckResponseIndicatesOrgIsAcceptable(orgCheckResponse) {
        // Anything other than a 404 or 403 will make this return true
        return (orgCheckResponse.status !== 404 && orgCheckResponse.status !== 403);
    }
    /**
     * Based on the passed-in value, this will determine whether or not we should check the org endpoint (again.)
     * If it is determined that the orgCheckResponse parameter has data and that the call should again be made,
     * this will return true after a waiting period which will back off 10 seconds each time it is called to avoid
     * spamming the endpoint.
     *
     * @param orgCheckResponse null or response from a previous call to check the org endpoint
     *
     */
    shouldCheckOrgEndpoint(orgCheckResponse) {
        return new Promise((resolve, reject) => {
            if (!orgCheckResponse) {
                resolve(true);
                return;
            }
            if (DefaultOrgCheck.orgCheckResponseIndicatesOrgIsDefinitelyInvalid(orgCheckResponse) ||
                DefaultOrgCheck.orgCheckResponseIndicatesOrgIsAcceptable(orgCheckResponse)) {
                resolve(false);
            }
            else {
                this.waitTimeUntilNextCall += 10000;
                setTimeout(() => {
                    resolve(true);
                }, this.waitTimeUntilNextCall);
            }
        });
    }
    /**
     * Determines if the org is valid.
     *
     * @param params
     * @returns true if the org is not definitely invalid, false if the org is definitely invalid. It will not return until it
     * can determine that one or the other is true.
     */
    async isOrgValid(params) {
        if (!params ||
            params.apiServer.length === 0 ||
            params.provisioningCode.length === 0) {
            const errStr = 'DefaultOrgCheck.isOrgValid(): Parameters missing.';
            this.client.logger.logError(errStr);
            throw new Error(errStr);
        }
        this.init();
        let orgCheckResponse = null;
        while (await this.shouldCheckOrgEndpoint(orgCheckResponse)) {
            try {
                orgCheckResponse = await this.getOrgCheckEndpointResult(params);
            }
            catch (err) {
                const errStr = 'DefaultOrgCheck.IsOrgValid() exception: ' + err;
                this.client.logger.logInfo(errStr);
                throw new Error(errStr);
            }
        }
        if (!orgCheckResponse ||
            DefaultOrgCheck.orgCheckResponseIndicatesOrgIsDefinitelyInvalid(orgCheckResponse)) {
            return false;
        }
        return true;
    }
}
exports.DefaultOrgCheck = DefaultOrgCheck;
//# sourceMappingURL=defaultOrgCheck.js.map