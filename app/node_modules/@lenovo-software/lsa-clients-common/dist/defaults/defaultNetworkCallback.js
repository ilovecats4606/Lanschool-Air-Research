"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultNetworkTransportOpts = exports.DefaultNetworkCallback = exports.PageToHead = void 0;
const internal_1 = require("../internal");
// tslint:disable-next-line: variable-name
exports.PageToHead = 'https://lanschoolair.lenovosoftware.com/';
class DefaultNetworkCallback {
    constructor() {
        this.waitRetryPeriod = 5000;
        this.waitNotificationListener = null;
        this.logger = internal_1.LSAClient.getInstance().logger;
    }
    setWaitNotificationListener(f) {
        this.waitNotificationListener = f;
    }
    async isDeviceOnline() {
        try {
            this.logger.logDebug('isDeviceOnline(): Calling fetch on LSA site...');
            const response = await fetch(exports.PageToHead, internal_1.httpAPI.getFetchHeaderObj('HEAD'));
            this.logger.logDebug('isDeviceOnline(): LSA site responded ok');
            return Promise.resolve(response.ok);
        }
        catch (err) {
            this.logger.logError('isDeviceOnline(): LSA site responded with an err:' + err.message);
            return Promise.resolve(false);
        }
    }
    async waitUntilDeviceIsOnline() {
        return new Promise((resolve) => {
            this.isDeviceOnline()
                .then((status) => {
                if (status === true) {
                    resolve();
                }
                else {
                    this.askAgainLater(resolve);
                }
            });
        });
    }
    askAgainLater(cb) {
        if (!cb) {
            throw new Error('DefaultNetworkCallback.askAgainLater(): No callback specified.');
        }
        if (this.waitNotificationListener) {
            this.waitNotificationListener.waitStartedEvent(this.waitRetryPeriod);
        }
        setTimeout(() => {
            if (this.waitNotificationListener) {
                this.waitNotificationListener.waitEndedEvent();
            }
            this.isDeviceOnline().then((online) => {
                if (online === true) {
                    cb();
                }
                else {
                    this.askAgainLater(cb);
                }
            });
        }, this.waitRetryPeriod);
    }
}
exports.DefaultNetworkCallback = DefaultNetworkCallback;
class DefaultNetworkTransportOpts {
    getSupportedSocketTransports() {
        return Promise.resolve(['websocket']);
    }
}
exports.DefaultNetworkTransportOpts = DefaultNetworkTransportOpts;
//# sourceMappingURL=defaultNetworkCallback.js.map