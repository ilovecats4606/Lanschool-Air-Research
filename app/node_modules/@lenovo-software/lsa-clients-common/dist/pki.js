"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PKI = void 0;
// For lsa-common-client
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
const preferences = new internal_1.StorageInterop();
class PKI {
    constructor() {
        pubsub_js_1.default.subscribe('onPrefsStorageRetrieved', () => {
            PKI.setupPKI();
        });
    }
    static setupPKI(callbackWhenDone) {
        this.privateJWK = preferences.getSetting('privateJWK');
        this.publicPEM = preferences.getSetting('publicPEM');
        this.privateKey = null;
        if (!this.privateJWK || !this.publicPEM) {
            logger.logMessage('Generating keys...');
            // If we are generating keys then we must be assured we are also going to re-provision
            internal_1.AccessToken.clearProvisioningPreferences(() => {
                // TODO: might need to convert this into async await -> tests are not executed properly
                internal_1.window.crypto.subtle
                    .generateKey({
                    name: this.algorithmName,
                    modulusLength: 2048,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: { name: this.hashName }
                }, true, ['sign', 'verify'])
                    .then((keyPair) => {
                    internal_1.window.crypto.subtle
                        .exportKey('jwk', keyPair.privateKey)
                        .then((jwk) => {
                        preferences.saveSetting('privateJWK', jwk);
                        this.privateJWK = jwk;
                        internal_1.window.crypto.subtle
                            .exportKey('spki', keyPair.publicKey)
                            .then((spki) => {
                            this.publicPEM =
                                this.convertBinaryToPem(spki, 'PUBLIC KEY', false);
                            preferences.saveSetting('publicPEM', this.publicPEM);
                            this.privateKey = keyPair.privateKey;
                            if (callbackWhenDone)
                                callbackWhenDone(true);
                        })
                            .catch(function (err) {
                            logger.logError('Error exporting public key: ' + err);
                            if (callbackWhenDone)
                                callbackWhenDone(false);
                        });
                    })
                        .catch(function (err) {
                        logger.logError('Error exporting private key: ' + err);
                        if (callbackWhenDone)
                            callbackWhenDone(false);
                    });
                })
                    .catch(function (err) {
                    logger.logError('Error creating key pair: ' + err.message);
                    if (callbackWhenDone)
                        callbackWhenDone(false);
                });
            });
        }
        else {
            logger.logMessage('Private key from prefs: FOUND');
            internal_1.window.crypto.subtle
                .importKey('jwk', this.privateJWK, {
                name: this.algorithmName,
                hash: { name: this.hashName }
            }, true, ['sign'])
                .then((privateKey) => {
                this.privateKey = privateKey;
                if (callbackWhenDone)
                    callbackWhenDone(true);
            })
                .catch((err) => {
                logger.logMessage('Error importing key: ' + err);
                if (callbackWhenDone)
                    callbackWhenDone(false);
            });
            logger.logMessage('Public PEM from prefs: ' + this.publicPEM.replace(/\r\n/g, ''));
        }
    }
    static signPayload(payload) {
        return new Promise((resolve, reject) => {
            if (!this.privateKey) {
                reject('PKI not setup');
            }
            else {
                internal_1.window.crypto.subtle
                    .sign({
                    name: this.algorithmName
                }, this.privateKey, payload)
                    .then((signed) => {
                    resolve(signed);
                })
                    .catch((err) => {
                    logger.logError('Error signing key: ' + err);
                    reject(err);
                });
            }
        });
    }
    static getJWT(param) {
        return new Promise((resolve, reject) => {
            var base64Header = (0, internal_1.SoftBase64Exchange)((0, internal_1.ArrayBufferToBase64ExPadding)(this.str2ab(JSON.stringify(param.header)), false));
            var base64Payload = (0, internal_1.SoftBase64Exchange)((0, internal_1.ArrayBufferToBase64ExPadding)(this.str2ab(JSON.stringify(param.payload)), false));
            var unsignedToken = base64Header + '.' + base64Payload;
            var signedToken = '';
            this.signPayload(this.str2ab(unsignedToken))
                .then((signed) => {
                var base64Signed = (0, internal_1.SoftBase64Exchange)((0, internal_1.ArrayBufferToBase64ExPadding)(signed, false));
                signedToken = unsignedToken + '.' + base64Signed;
                resolve(signedToken);
            })
                .catch((err) => {
                logger.logError('Error getJWT: ' + err);
                reject(err);
            });
        });
    }
    static pkiLoaded() {
        return this.privateJWK && this.publicPEM && this.privateKey;
    }
    static convertBinaryToPem(binaryData, label, scriptReady) {
        var base64Cert = (0, internal_1.ArrayBufferToBase64Ex)(binaryData);
        var pemCert = '-----BEGIN ' + label + '-----\r\n';
        var nextIndex = 0;
        while (nextIndex < base64Cert.length) {
            if (nextIndex + 64 <= base64Cert.length) {
                if (scriptReady)
                    pemCert +=
                        '"' +
                            base64Cert.substring(nextIndex, 64 + nextIndex) +
                            '\\n" + \r\n';
                else
                    pemCert +=
                        base64Cert.substring(nextIndex, 64 + nextIndex) +
                            '\r\n';
            }
            else {
                if (scriptReady)
                    pemCert +=
                        '"' + base64Cert.substring(nextIndex) + '\\n" + \r\n';
                else
                    pemCert += base64Cert.substring(nextIndex) + '\r\n';
            }
            nextIndex += 64;
        }
        pemCert += '-----END ' + label + '-----\r\n';
        return pemCert;
    }
    ;
}
exports.PKI = PKI;
PKI.algorithmName = 'RSASSA-PKCS1-v1_5';
PKI.hashName = 'SHA-256';
PKI.str2ab = (str) => {
    var enc = new TextEncoder();
    var buf = enc.encode(str);
    return buf;
};
//# sourceMappingURL=pki.js.map