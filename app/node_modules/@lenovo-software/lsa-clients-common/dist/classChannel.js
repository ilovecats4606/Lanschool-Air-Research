"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassChannel = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
class ClassChannel {
    constructor(socketIO, orgVerificationController, orgDataRetriever, storage) {
        this.socketIO = socketIO;
        this.orgVerificationController = orgVerificationController;
        this.orgDataRetriever = orgDataRetriever;
        this.storage = storage;
        pubsub_js_1.default.subscribe('onConnectionStateChange', (msg, data) => {
            const stateChangeData = internal_1.ConnectionStateChangeEventModel.fromAny(data);
            if (stateChangeData.connected !== internal_1.ConnectivityStatus.Connected) {
                logger.logMessage('Detected disconnect - leaving class...');
                this.leaveCurrentClass();
            }
        });
        pubsub_js_1.default.subscribe('onJoinClass', (msg, data) => {
            this.joinClassMsgReceived(data);
        });
        pubsub_js_1.default.subscribe('onLeaveClass', (msg, data) => {
            if (data)
                this.leaveClass(data);
            else
                this.leaveCurrentClass();
        });
    }
    getClassID() {
        var _a;
        if ((_a = this.currentClassData) === null || _a === void 0 ? void 0 : _a.classID) {
            return this.currentClassData.classID;
        }
        return '';
    }
    getActiveClassID() {
        var _a;
        if ((_a = this.currentClassData) === null || _a === void 0 ? void 0 : _a.activeClassID) {
            return this.currentClassData.activeClassID;
        }
        return '';
    }
    getChatHistoryEnabled() {
        var _a;
        if ((_a = this.currentClassData) === null || _a === void 0 ? void 0 : _a.chatHistoryEnabled) {
            return this.currentClassData.chatHistoryEnabled;
        }
        return false;
    }
    getWebHistoryEnabled() {
        var _a;
        if ((_a = this.currentClassData) === null || _a === void 0 ? void 0 : _a.webHistoryEnabled) {
            return this.currentClassData.webHistoryEnabled;
        }
        return false;
    }
    getClassName() {
        var _a;
        if ((_a = this.currentClassData) === null || _a === void 0 ? void 0 : _a.className) {
            return this.currentClassData.className;
        }
        return '';
    }
    joinClass(classData) {
        logger.logMessage("Joining class '" + classData.rooms.studentRoom + "'.");
        this.currentClassData = classData;
        this.socketIO.setClassSocketDestination(this.currentClassData.rooms.teacherRoom);
        this.socketIO.joinRoom(this.currentClassData, this.getUserAgentVersion());
        return true;
    }
    joinClassMsgReceived(classData) {
        if (this.currentClassData) {
            if (classData &&
                this.currentClassData.classID === classData.classID) {
                // Same class we're already in so no need to process anything else
                return true;
            }
            this.leaveClass(this.currentClassData, classData);
            this.currentClassData = undefined;
        }
        if (!classData) {
            logger.logMessage('ERROR: classData is null');
            return false;
        }
        if (!classData.classID ||
            !classData.rooms.teacherRoom ||
            !classData.rooms.studentRoom) {
            logger.logMessage('ERROR: Cannot join class due to malformed joinClass data: ' +
                JSON.stringify(classData));
            return false;
        }
        // Parse the classData object as received from the socket message. There are three possibilities:
        // 1. Org explicitly does not require opt-in (requireDeviceMonitoringOptIn === false.) 
        //    This is the default for verified orgs.
        // 2. Org explicitly requires opt-in (requireDeviceMonitoringOptIn === true.)
        //    This can be chosen by the org admin so that students are always prompted.
        // 3. Org *may* require opt-in. (requireDeviceMonitoringOptIn not set.)
        //    We will need to call the server to determine whether or not the org is verified.
        if (classData.requireDeviceMonitoringOptIn === false) {
            return this.joinClass(classData);
        }
        else {
            this.orgVerificationController.setCallback((proceed) => {
                if (proceed) {
                    this.joinClass(classData);
                }
            });
            if (classData.requireDeviceMonitoringOptIn === true) {
                this.orgVerificationController.handleRequireDeviceMonitoringOptIn();
            }
            else {
                const apiServer = this.storage.loadAPIServer();
                const provisioningCode = this.storage.loadProvisioningCode();
                if (!apiServer || !provisioningCode) {
                    logger.logError(`ERROR: ClassChannel.joinClassMsgReceived: Missing info to perform org verification. ${JSON.stringify([apiServer, provisioningCode])}`);
                    return false;
                }
                this.orgDataRetriever.setRetrieverParamsForOrgVerification(apiServer, provisioningCode);
                this.orgVerificationController.handleOrgVerification(this.orgDataRetriever);
            }
        }
        return true;
    }
    getUserAgentVersion() {
        if (typeof internal_1.LSAClient !== 'undefined') {
            return internal_1.LSAClient.getInstance().storage.loadOsString();
        }
        if (window && window.navigator) {
            let userAgent = window.navigator.userAgent || '';
            if (userAgent.length > 0) {
                let regExp = /Chrome\/([0-9.]+)/.exec(userAgent);
                if (regExp && regExp.length > 1) {
                    return 'CrOS ' + regExp[1];
                }
            }
        }
        return '';
    }
    leaveCurrentClass() {
        if (this.currentClassData)
            this.leaveClass(this.currentClassData);
    }
    leaveClass(classData, newClassData) {
        if (!classData) {
            logger.logMessage('ERROR: classData is null');
            return false;
        }
        if (!classData.classID ||
            !classData.rooms ||
            !classData.rooms.teacherRoom) {
            logger.logMessage('ERROR: Cannot leave class due to malformed leaveClass data: ' +
                JSON.stringify(classData));
            return false;
        }
        // CSS-1452 - Check the leave class against the current class. If the leave class doesn't match the current class ID, don't dismiss.
        if (this.currentClassData &&
            classData.classID !== this.currentClassData.classID) {
            logger.logMessage("Leave class requested but class ID doesn't match the class we are currently in.");
            return false;
        }
        logger.logMessage("Leaving class '" + classData.rooms.studentRoom + "'.");
        internal_1.chrome.runtime.sendMessage({ message: 'endsession' });
        if (!newClassData) {
            newClassData = new internal_1.ActiveClassEventModel();
        }
        if (!newClassData.teacherInfo) {
            newClassData.teacherInfo = { firstName: '', lastName: '' };
        }
        this.socketIO.setClassSocketDestination('[UNDEFINED]');
        this.socketIO.leaveRoom({
            studentRoom: classData.rooms.studentRoom,
            teacherRoom: classData.rooms.teacherRoom,
            newClassName: newClassData.className,
            newClassId: newClassData.classID,
            newTeacherInfo: newClassData.teacherInfo,
            classChannel: this
        });
        if (this.currentClassData) {
            this.currentClassData = undefined;
        }
        pubsub_js_1.default.publish('onLeaveClassPostProcess', {
            classID: classData.classID
        });
        return true;
    }
    wasStudentStolenFromActiveClass(obj) {
        return !!(obj && obj.newClassId && obj.newClassId.length > 0);
    }
}
exports.ClassChannel = ClassChannel;
//# sourceMappingURL=classChannel.js.map