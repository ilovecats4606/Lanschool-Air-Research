"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
class Utils {
    static getEmailDomainFromEmailAddr(emailAddr) {
        if (!emailAddr || emailAddr.length === 0) {
            throw new Error('Invalid emailAddr');
        }
        const arr = emailAddr.split('@');
        if (!arr || !Array.isArray(arr) || arr.length < 2) {
            throw new Error('Invalid email address supplied.');
        }
        return arr[1];
    }
    static isElectron() {
        return !!process.versions['electron'];
    }
    /**
     * Waits for the given event to be emitted from the given EventEmitter, with a timeout to prevent infinite waiting.
     *
     * @param eventName The name of the event to listen for on the given EventEmitter instance.
     * @param events The EventEmitter instance that will emit the given event.
     * @param timeoutMs Maximum duration, in milliseconds, to wait before timing out and rejecting the promise with an error message
     * indicating failure due to timeout.
     * @returns A Promise that resolves when the specified event is emitted or rejects if a timeout occurs before the event is received.
     */
    static async waitForEvent(eventName, events, timeoutMs = 5000) {
        return new Promise((resolve, reject) => {
            let timeoutId;
            let eventHandler;
            // Set a timeout so that we are not waiting forever.
            timeoutId = setTimeout(() => {
                // Timeout hit, so call reject with an error message indicating the failure due to timeout.
                reject(new Error(`Hit ${timeoutMs} ms timeout while waiting for event ${eventName}.`));
                // Remove the eventHandler, which should always exist, but check just in case.
                if (eventHandler) {
                    events.removeListener(eventName, eventHandler);
                }
            }, timeoutMs);
            // Subscribe to the event, but only once.
            eventHandler = () => {
                // Event was called, so resolve the promise indicating success.
                resolve();
                // Clear the timeout to prevent it from triggering later since the event was already received.
                clearTimeout(timeoutId);
            };
            events.once(eventName, eventHandler);
        });
    }
}
exports.Utils = Utils;
//# sourceMappingURL=utils.js.map