"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConferenceController = void 0;
// For lsa-common-client
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const internal_1 = require("./internal");
const defs_1 = require("./js/defs");
const logger = new internal_1.LoggerInterop();
class ConferenceController {
    constructor(settings) {
        this.classId = '';
        this.apiServer = '';
        this.conferenceAttendeeNames = [];
        this.conferenceState = defs_1.ConferenceStateEnum.Disconnected;
        this.previousConferenceState = defs_1.ConferenceStateEnum.Disconnected;
        this.inProcessStateTimeout = null;
        this.studentScreenShareRequestData = null;
        this.inProcessTimeoutLength = 8000;
        // FIXME: 'UNUSED' is passed in settings, need to pass correct value
        this.webViewWindowController = settings.webViewWindowController;
        this.apiServer = settings.apiServer;
        this.startQueue = new internal_1.CallbackQueue();
        this.restartQueue = new internal_1.CallbackQueue();
        this.conferenceDataRetriever = new internal_1.ConferenceDataRetriever({
            apiServer: settings.apiServer,
            deviceId: settings.deviceId,
            provisioningCode: settings.provisioningCode
        });
        this.lsaClient = internal_1.LSAClient.getInstance();
        pubsub_js_1.default.subscribe('onJoinClass', (msg, data) => {
            if (!data.classID)
                return;
            if (this.classId.length > 0) {
                // We are already in a class...
                if (data.classID !== this.classId) {
                    // But we are joining a different class so dump the current conference
                    logger.logMessage('ConferenceController.onJoinClass: Ending current conference...');
                    this.endAllConferencing();
                }
            }
            this.classId = data.classID;
            logger.logMessage('ConferenceController.onJoinClass: classId: ' + this.classId);
        });
        pubsub_js_1.default.subscribe('onBeginViewBroadcast', (msg, data) => {
            this.startConference(data, defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
        });
        pubsub_js_1.default.subscribe('onEndViewBroadcast', (msg, data) => {
            this.endConference(defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
        });
        pubsub_js_1.default.subscribe('onBeginAudioBroadcast', (msg, data) => {
            this.startConference(data, defs_1.TEACHER_CONFERENCE_TYPE_AUDIO);
        });
        pubsub_js_1.default.subscribe('onEndAudioBroadcast', (msg, data) => {
            this.endConference(defs_1.TEACHER_CONFERENCE_TYPE_AUDIO);
        });
        pubsub_js_1.default.subscribe('onShareStudentScreenRequest', (msg, data) => {
            var _a, _b;
            logger.logMessage('ConferenceController received: onShareStudentScreenRequest');
            (_a = this.lsaClient.studentScreenShare) === null || _a === void 0 ? void 0 : _a.setTeacherOriginator(data.teacherOriginator);
            delete data.teacherOriginator;
            this.studentScreenShareRequestData = data;
            (_b = this.lsaClient.studentScreenShareController) === null || _b === void 0 ? void 0 : _b.requestStudentScreenShare();
        });
        pubsub_js_1.default.subscribe('onCancelStudentScreenShareRequest', (msg, data) => {
            var _a;
            logger.logMessage('ConferenceController received: onCancelStudentScreenShareRequest');
            if (this.studentScreenShareRequestData && this.studentScreenShareRequestData.conferenceId === data.conferenceId && this.studentScreenShareRequestData.conferenceServerId === data.conferenceServerId) {
                (_a = this.lsaClient.studentScreenShareController) === null || _a === void 0 ? void 0 : _a.cancelStudentScreenShareRequest();
                this.studentScreenShareRequestData = null;
            }
        });
        pubsub_js_1.default.subscribe('onAcceptStudentScreenShare', (msg, data) => {
            logger.logMessage('ConferenceController received: onAcceptStudentScreenShare');
            if (this.studentScreenShareRequestData) {
                this.startConference(this.studentScreenShareRequestData, defs_1.STUDENT_CONFERENCE_TYPE_VIDEO);
            }
        });
        pubsub_js_1.default.subscribe('onStopStudentScreenShare', (msg, data) => {
            logger.logMessage('ConferenceController received: onStopStudentScreenShare');
            this.endConference(defs_1.STUDENT_CONFERENCE_TYPE_VIDEO);
        });
        pubsub_js_1.default.subscribe('onStartStudentScreenViewBroadcast', (msg, data) => {
            var _a;
            logger.logMessage('ConferenceController received: onStartStudentScreenViewBroadcast');
            let provisioningData = this.lsaClient.storage.loadProvisioningData();
            if (data.studentID === (provisioningData === null || provisioningData === void 0 ? void 0 : provisioningData.id)) {
                logger.logWarning('ConferenceController.onStartStudentScreenViewBroadcast: This student is sharing the screen, so can not view broadcast');
                return;
            }
            if (data.shareWithClass) {
                /**
                 * Start viewing broadcast only if teacher is sharing with whole class
                 * (i.e. includes teacher room and student room)
                 * teacher sends `startStudentScreenViewBroadcast` to student room
                 * with shareWithClass = true
                 */
                this.startConference(data, defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
            }
            else {
                /**
                 * If teacher is not sharing with class, then
                 * Case 1: student room doesn't receive socket message
                 * Case 2: Change from `Share with Class` to `Share with Me`:
                 *        - teacher shares with class (starts view broadcast in if branch)
                 *        - teacher shifts to `Share with Me`,
                 *          - teacher sends `startStudentScreenViewBroadcast` to student room
                 *            with shareWithClass = false
                 */
                this.endConference(defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
                /**
                 * NOTE:
                 * Need this to stop & remove view screen on student window as
                 * when switched to `Share with Me`, Teacher just sends the socket message
                 * and None of the LESS SDK events (i.e. broadcaststop/conferencedied) are triggered
                 * that stop the view broadcast
                 */
                (_a = this.lsaClient.studentScreenShareController) === null || _a === void 0 ? void 0 : _a.endStudentScreenViewBroadcast();
            }
        });
        pubsub_js_1.default.subscribe('onEndStudentScreenViewBroadcast', (msg, data) => {
            var _a;
            logger.logMessage('ConferenceController received: onEndStudentScreenViewBroadcast');
            let provisioningData = this.lsaClient.storage.loadProvisioningData();
            if (data.studentID === (provisioningData === null || provisioningData === void 0 ? void 0 : provisioningData.id)) {
                logger.logWarning('ConferenceController.onEndStudentScreenViewBroadcast: This student is sharing the screen, so not viewing any screen broadcast');
                return;
            }
            /**
             * NOTE:
             * No need to call `handleEndStudentScreenViewBroadcast` as `stopStudentScreenBroadcast`
             * which is called before this, triggers `broadcaststop` LEES SDK,
             * and event listener on `student` side stops view broadcast
             * and removes the view screen at `videoStream.ts`
             */
            this.endConference(defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
            // Reset the teacherOriginator to empty string on complete screen share close
            (_a = this.lsaClient.studentScreenShare) === null || _a === void 0 ? void 0 : _a.setTeacherOriginator('');
        });
        pubsub_js_1.default.subscribe('onConnectionStateChange', (msg, data) => {
            if (data.connected != defs_1.ConnectionStateEnum.Connected) {
                logger.logMessage('ConferenceController.onConnectionStateChange: Detected disconnect - quitting conference...');
                this.endAllConferencing();
            }
        });
        pubsub_js_1.default.subscribe('onLeaveClass', (msg, data) => {
            logger.logMessage('ConferenceController.onLeaveClass - quitting conference...');
            this.classId = '';
            this.endAllConferencing();
        });
        pubsub_js_1.default.subscribe('onHeartbeatTimeout', (msg, data) => {
            this.endAllConferencing();
        });
        pubsub_js_1.default.subscribe('onChatWindowClosed', (msg, data) => {
            logger.logMessage('ConferenceController.onChatWindowClosed: Viewer gone!');
            this.startQueue.clearQueue();
            if (!this.conferenceData)
                return;
            if (this.conferenceData.conferenceType & defs_1.TEACHER_CONFERENCE_TYPE_AUDIO) {
                this.restartQueue.queueCommand(() => {
                    logger.logMessage('ConferenceController.onChatWebViewReady: Restarting audio...');
                    this.startConference(this.teacherData, defs_1.TEACHER_CONFERENCE_TYPE_AUDIO);
                });
            }
            if (this.conferenceData.conferenceType & defs_1.TEACHER_CONFERENCE_TYPE_VIDEO) {
                this.restartQueue.queueCommand(() => {
                    logger.logMessage('ConferenceController.onChatWebViewReady: Restarting video...');
                    this.startConference(this.teacherData, defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
                });
            }
        });
        pubsub_js_1.default.subscribe('onChatWebViewReady', (msg, data) => {
            this.restartQueue.executeQueuedCommand();
        });
        pubsub_js_1.default.subscribe('onConferenceAttendeeNames', (msg, data) => {
            if ('conferenceAttendeeNames' in data) {
                this.conferenceAttendeeNames = data.conferenceAttendeeNames;
                this.handleConferenceAttendeeNames();
            }
            else {
                logger.logError('ConferenceController.onConferenceAttendeeNames: ERROR: Missing \'conferenceAttendeeNames\' property');
            }
        });
        internal_1.chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
            switch (request.message) {
                case 'FromUI_ConferenceAttachComplete': {
                    logger.logMessage('ConferenceController received ' + request.message);
                    this.setConferenceState(defs_1.ConferenceStateEnum.Connected);
                    this.handleConferenceAttendeeNames();
                    this.executeQueues();
                    break;
                }
                case 'FromUI_ConferenceDetachComplete': {
                    logger.logMessage('ConferenceController received ' + request.message);
                    this.setConferenceState(defs_1.ConferenceStateEnum.Disconnected);
                    this.startQueue.clearQueue();
                    this.restartQueue.clearQueue();
                    break;
                }
                case 'FromUI_ConferenceError': {
                    // TODO: Notify status window that this failed.
                    logger.logMessage('ConferenceController received ' + JSON.stringify(request));
                    this.startQueue.clearQueue();
                    this.restartQueue.clearQueue();
                    this.endAllConferencing();
                    break;
                }
                case 'FromUI_ClickInSpeakerAudioView': {
                    logger.logMessage('ConferenceController received ' + JSON.stringify(request));
                    this.webViewWindowController.restoreChatWindow();
                    break;
                }
                case 'FromUI_ConferenceAttendeeId': {
                    logger.logMessage('ConferenceController received ' + JSON.stringify(request));
                    pubsub_js_1.default.publish('onConferenceAttendeeId', request.data);
                    break;
                }
            }
        });
    }
    executeQueues() {
        if (!this.restartQueue.executeQueuedCommand()) {
            // These queues really *should* be mutually exclusive. The start queue
            // should be cleared out if we're in the middle of a restart so we shouldn't
            // even need this goofy check but just in case we have a start queue with
            // stuff in it, we don't want to lose those commands.
            this.startQueue.executeQueuedCommand();
        }
    }
    endAllConferencing() {
        this.endConference(defs_1.TEACHER_CONFERENCE_TYPE_AUDIO);
        this.endConference(defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
        this.endConference(defs_1.STUDENT_CONFERENCE_TYPE_VIDEO);
        this.conferenceAttendeeNames = [];
        this.setConferenceState(defs_1.ConferenceStateEnum.Disconnected);
    }
    setConferenceState(conferenceState) {
        this.previousConferenceState = this.conferenceState;
        if (this.inProcessStateTimeout) {
            clearTimeout(this.inProcessStateTimeout);
            this.inProcessStateTimeout = null;
        }
        if (conferenceState === defs_1.ConferenceStateEnum.InProcess) {
            this.inProcessStateTimeout = setTimeout(() => {
                if (this.conferenceState === defs_1.ConferenceStateEnum.InProcess) {
                    this.conferenceState = this.previousConferenceState;
                }
                logger.logMessage('ConferenceController.setConferenceState(): In Process state timed out. Previous state => \'' +
                    this.previousConferenceState + '\'. Restart queue length: ' +
                    this.restartQueue.cmdQueue.length + '. Start queue length: ' + this.startQueue.cmdQueue.length);
                this.executeQueues();
                this.inProcessStateTimeout = null;
            }, this.inProcessTimeoutLength);
        }
        this.conferenceState = conferenceState;
        logger.logMessage('ConferenceController.setConferenceState(): State set to ' + this.conferenceState);
    }
    storeParameters(conferenceData, teacherData) {
        var _a, _b;
        conferenceData.conferenceType = (_b = (_a = this.conferenceData) === null || _a === void 0 ? void 0 : _a.conferenceType) !== null && _b !== void 0 ? _b : defs_1.TEACHER_CONFERENCE_TYPE_NONE;
        this.conferenceData = conferenceData;
        this.teacherData = teacherData;
    }
    addConferenceType(conferenceType) {
        logger.logInfo('ConferenceController.addConferenceType(+)');
        logger.logDebug('ConferenceController.addConferenceType: conferenceType: ' + conferenceType + ', conferenceData: ' + JSON.stringify(this.conferenceData));
        this.conferenceData.conferenceType |= conferenceType;
    }
    removeConferenceType(conferenceType) {
        var _a;
        logger.logInfo('ConferenceController.removeConferenceType(+)');
        logger.logDebug('ConferenceController.removeConferenceType: conferenceType: ' + conferenceType + ', conferenceData: ' + JSON.stringify(this.conferenceData));
        if (((_a = this.conferenceData) === null || _a === void 0 ? void 0 : _a.conferenceType) &&
            !!(this.conferenceData.conferenceType & conferenceType)) {
            this.conferenceData.conferenceType ^= conferenceType;
        }
    }
    notifyBeginMediaBroadcast() {
        pubsub_js_1.default.publish('BeginMediaBroadcast', {
            apiServer: this.apiServer,
            classId: this.classId,
            conferenceData: this.conferenceData,
            teacherData: this.teacherData
        });
    }
    notifyEndMediaBroadcast() {
        logger.logMessage('ConferenceController.notifyEndMediaBroadcast(+)');
        pubsub_js_1.default.publish('EndMediaBroadcast');
    }
    startConference(teacherData, conferenceType) {
        const isAudioConference = !!(conferenceType & defs_1.TEACHER_CONFERENCE_TYPE_AUDIO);
        const isViewingConference = !!(conferenceType & defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
        const isSharingScreen = !!(conferenceType & defs_1.STUDENT_CONFERENCE_TYPE_VIDEO);
        const typeLog = isAudioConference ? 'Audio' : isViewingConference ? 'Viewing' : 'ScreenBroadcast';
        logger.logMessage('ConferenceController.startConference(+): Starting ' + typeLog + ' conference');
        if (!teacherData) {
            logger.logError('ConferenceController.startConference(): teacherData parameter is missing.');
            return;
        }
        if (teacherData.mediaHandle && teacherData.mediaHandle.length > 0) {
            if (isAudioConference) {
                // NOTE: `audioMediaHandle` is not being used in audioController,
                // not sure if we need it at all
                teacherData.audioMediaHandle = teacherData.mediaHandle;
            }
            if (isViewingConference) {
                teacherData.videoMediaHandle = teacherData.mediaHandle;
            }
            delete teacherData.mediaHandle;
        }
        if (this.conferenceState === defs_1.ConferenceStateEnum.InProcess) {
            logger.logMessage('ConferenceController.startConference(): Conference join already in process. Queueing ' + typeLog + ' conference...');
            this.startQueue.queueCommand(() => {
                logger.logMessage('ConferenceController.startConference(): Starting' + typeLog + ' conference from queue...');
                this.startConference(this.teacherData, conferenceType);
            });
        }
        else {
            this.setConferenceState(defs_1.ConferenceStateEnum.InProcess);
            this.conferenceDataRetriever.getConferenceData(teacherData, this.classId, conferenceType).then((conferenceData) => {
                this.storeParameters(conferenceData, teacherData);
                this.addConferenceType(conferenceType);
                if (isSharingScreen) {
                    teacherData.windowed = true;
                }
                this.notifyBeginMediaBroadcast();
                const conferenceState = {
                    mode: 'Start',
                    type: isAudioConference ? 'Audio' : isViewingConference ? 'Video' : 'Screen'
                };
                if (isViewingConference) {
                    conferenceState.view = teacherData.windowed ? 'Window' : 'Full Screen';
                }
                pubsub_js_1.default.publish('onConferenceState', conferenceState);
            }).catch((err) => {
                logger.logError('ConferenceController.startConference(): Error getting ' + typeLog + ' conferenceData: ' + err);
            });
        }
    }
    endConference(conferenceType) {
        var _a;
        const isAudioConference = !!(conferenceType & defs_1.TEACHER_CONFERENCE_TYPE_AUDIO);
        const isViewingConference = !!(conferenceType & defs_1.TEACHER_CONFERENCE_TYPE_VIDEO);
        const isSharingScreen = !!(conferenceType & defs_1.STUDENT_CONFERENCE_TYPE_VIDEO);
        const typeLog = isAudioConference ? 'Audio' : isViewingConference ? 'Viewing' : '';
        logger.logMessage('ConferenceController.endConference(+): Ending ' + typeLog + ' conference...');
        this.removeConferenceType(conferenceType);
        // FIXME: Why queues are cleared in case of end view conference only
        if (isViewingConference) {
            this.restartQueue.clearQueue();
            this.startQueue.clearQueue();
        }
        pubsub_js_1.default.publish('onConferenceState', {
            mode: 'End',
            type: isAudioConference ? 'Audio' : isViewingConference ? 'Video' : 'Screen'
        });
        if (isAudioConference || isViewingConference) {
            if (this.conferenceData && this.conferenceData.conferenceType !== defs_1.TEACHER_CONFERENCE_TYPE_NONE) {
                this.setConferenceState(defs_1.ConferenceStateEnum.InProcess);
                this.notifyBeginMediaBroadcast();
            }
            else {
                this.notifyEndMediaBroadcast();
            }
        }
        if (isSharingScreen) {
            /**
             * NOTE: leaveClass triggers conferenceStop, which stops screen broadcast
             * but the screen sharing window is not closed, hence calling close window.
             */
            (_a = this.lsaClient.studentScreenShareController) === null || _a === void 0 ? void 0 : _a.closeWindow();
        }
    }
    handleConferenceAttendeeNames() {
        if (this.conferenceAttendeeNames.length > 0) {
            logger.logMessage('ConferenceController.handleConferenceAttendeeNames(): Sending names to webview...');
            internal_1.chrome.runtime.sendMessage({
                message: 'SetConferenceAttendeeNames',
                data: this.conferenceAttendeeNames
            });
        }
        else {
            logger.logMessage('ConferenceController.handleConferenceAttendeeNames(): Empty list.');
        }
    }
}
exports.ConferenceController = ConferenceController;
//# sourceMappingURL=conferenceController.js.map