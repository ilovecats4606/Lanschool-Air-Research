"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LimitingRequestHandler = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
require("isomorphic-fetch");
const defs_1 = require("./js/defs");
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
class BlankScreenParametersInitializer {
    static async prepareParameters(request, className) {
        const limitingInterface = internal_1.LSAClient.getInstance().clientLimiting;
        if (!limitingInterface || !request) {
            const err = 'BlankScreenParametersInitializer.prepareParameters(): No limiting interface or malformed request.';
            return Promise.reject(err);
        }
        const params = new internal_1.BlankScreenParameters();
        params.backgroundUrl =
            request.image && request.image.url
                ? request.image.url
                : '';
        const backgroundImageRetriever = limitingInterface.getBackgroundImageRetriever();
        if (backgroundImageRetriever) {
            logger.logDebug('BlankScreenParametersInitializer.prepareParameters(): Calling implemented background image retriever.');
            params.backgroundImage =
                await backgroundImageRetriever.retrieveBackgroundImage();
        }
        else {
            try {
                params.backgroundImage = await this.retrieveBackgroundImage(params.backgroundUrl);
            }
            catch (err) {
                logger.logError('BlankScreenParametersInitializer.prepareParameters(): Error retrieving image: ' + err);
            }
        }
        params.screenMessage = request.message;
        params.className = className;
        params.shouldBlockInput = request.shouldBlockInput;
        return params;
    }
    static async retrieveBackgroundImage(url) {
        logger.logDebug('BlankScreenParametersInitializer.retrieveBackgroundImage() url = ' + url);
        const response = await fetch(url, internal_1.httpAPI.getFetchHeaderObj('GET'));
        const status = await response.status;
        logger.logDebug('BlankScreenParametersInitializer.retrieveBackgroundImage: response = ' + status);
        return await response.arrayBuffer();
    }
}
class WebLimitParametersInitializer {
    static async prepareParameters(request) {
        const params = new internal_1.WebLimitParams();
        if (request.websites.blockAll) {
            params.blockType = internal_1.WebLimitBlockType.BlockAll;
        }
        else if (request.websites.allowed &&
            request.websites.allowed.length > 0) {
            params.blockType = internal_1.WebLimitBlockType.Allow;
            params.sites = request.websites.allowed;
        }
        else if (request.websites.blocked &&
            request.websites.blocked.length > 0) {
            params.blockType = internal_1.WebLimitBlockType.Block;
            params.sites = request.websites.blocked;
        }
        else {
            params.blockType = internal_1.WebLimitBlockType.None;
        }
        params.blockIPAddresses = request.websites.blockIPAddresses;
        params.blockIncognito = request.websites.blockIncognito;
        params.blockEdge = request.websites.blockEdge;
        return Promise.resolve(params);
    }
}
class AppLimitParametersInitializer {
    static async prepareParameters(request) {
        const params = new internal_1.AppLimitParams();
        if (request.applications.limit === true &&
            request.applications.allowed &&
            request.applications.allowed.length > 0) {
            params.blockType = internal_1.AppLimitBlockType.Allow;
            params.apps = request.applications.allowed;
        }
        else if (request.applications.limit === true &&
            request.applications.blocked &&
            request.applications.blocked.length > 0) {
            params.blockType = internal_1.AppLimitBlockType.Block;
            params.apps = request.applications.blocked;
        }
        else {
            params.blockType = internal_1.AppLimitBlockType.None;
        }
        return Promise.resolve(params);
    }
}
const DesktopLimitingPriority = 50;
class LimitingRequestHandler {
    constructor() {
        this._currentClass = '';
        this._fullScreenActivityDirector = internal_1.FullScreenActivityDirector.getInstance();
        pubsub_js_1.default.subscribe('onLimitState', (msg, data) => {
            logger.logMessage('Received onLimitState event');
            this.handleLimitingRequest(data.limitStateMessage);
        });
        pubsub_js_1.default.subscribe('onJoinClassPostProcess', (msg, data) => {
            this._currentClass = data.className;
        });
        pubsub_js_1.default.subscribe('onLeaveClassPostProcess', () => {
            this.stopAllLimiting();
            this._currentClass = '';
        });
        pubsub_js_1.default.subscribe('onConnectionStateChange', (msg, data) => {
            if (data && data.connected !== defs_1.ConnectionStateEnum.Connected) {
                this.stopAllLimiting();
            }
        });
        pubsub_js_1.default.subscribe('onHeartbeatTimeout', () => {
            this.stopAllLimiting();
        });
    }
    get currentClass() {
        return this._currentClass;
    }
    async startFullScreenActivity(parameters) {
        logger.logDebug('LimitingRequestHandler.startFullScreenActivity(+)');
        try {
            const params = await BlankScreenParametersInitializer.prepareParameters(parameters.activityParameters, this._currentClass);
            await parameters.limitingInterface.showBlankScreen(params);
        }
        catch (err) {
            logger.logError('startFullScreenActivity exception: ' + err);
        }
    }
    async stopFullScreenActivity(parameters) {
        logger.logDebug('LimitingRequestHandler.stopFullScreenActivity(+)');
        await parameters.limitingInterface.hideBlankScreen();
    }
    async stopAllLimiting() {
        logger.logMessage('Limiting.stopAllLimiting(+)');
        await this.handleLimitingRequest(new internal_1.LimitStateMessage());
    }
    async handleLimitingRequest(request) {
        try {
            logger.logDebug('handleLimitingRequest(+) ' + JSON.stringify(request));
            await this.processDesktopLimiting(request);
            await this.processWebLimiting(request);
            await this.processAppLimiting(request);
        }
        catch (err) {
            logger.logError('handleLimitingRequest(+) : ' + err);
        }
    }
    async processDesktopLimiting(request) {
        var _a, _b;
        const limitingInterface = internal_1.LSAClient.getInstance().clientLimiting;
        if (!limitingInterface) {
            logger.logWarning('LimitingRequestHandler.processDesktopLimiting(): No limiting interface.');
            return;
        }
        if (request.desktop.limit === true) {
            var activityParameters = request.desktop;
            if (activityParameters) {
                let shouldBlockInput = (_b = (_a = internal_1.LSAClient.getInstance()) === null || _a === void 0 ? void 0 : _a.blankScreenConfigurationController) === null || _b === void 0 ? void 0 : _b.getShouldBlockInputDuringBlankScreen();
                activityParameters["shouldBlockInput"] = shouldBlockInput;
            }
            await this._fullScreenActivityDirector.queueActivity(DesktopLimitingPriority, this, {
                limitingInterface,
                activityParameters
            });
        }
        else {
            await this._fullScreenActivityDirector.removeActivity(DesktopLimitingPriority);
        }
    }
    async processWebLimiting(request) {
        const limitingInterface = internal_1.LSAClient.getInstance().clientLimiting;
        if (!limitingInterface) {
            logger.logWarning('LimitingRequestHandler.processWebLimiting(): No limiting interface.');
            return;
        }
        if (request.websites.limit === true) {
            try {
                const params = await WebLimitParametersInitializer.prepareParameters(request);
                params.className = this._currentClass;
                await limitingInterface.webLimitStart(params);
            }
            catch (err) {
                logger.logError('processWebLimiting exception: ' + err);
            }
        }
        else {
            await limitingInterface.webLimitStop();
        }
    }
    async processAppLimiting(request) {
        const limitingInterface = internal_1.LSAClient.getInstance().clientLimiting;
        if (!limitingInterface) {
            logger.logWarning('LimitingRequestHandler.processAppLimiting(): No limiting interface.');
            return;
        }
        if (request.applications.limit === true) {
            try {
                const params = await AppLimitParametersInitializer.prepareParameters(request);
                params.className = this._currentClass;
                await limitingInterface.appLimitStart(params);
            }
            catch (err) {
                logger.logError('processAppLimiting exception: ' + err);
            }
        }
        else {
            await limitingInterface.appLimitStop();
        }
    }
}
exports.LimitingRequestHandler = LimitingRequestHandler;
//# sourceMappingURL=limitingRequestHandler.js.map