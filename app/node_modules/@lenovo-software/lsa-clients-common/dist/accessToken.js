"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessToken = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
const preferences = new internal_1.StorageInterop();
const LStudent = new internal_1.LStudentInterop();
class AccessToken {
    static clearProvisioningPreferences(callback) {
        preferences.removeSetting([
            'privateJWK',
            'publicPEM',
            'provisioningData',
            'provisioningParams',
            'token',
            'iat'
        ], callback);
    }
    static hasProvisionedBefore() {
        return preferences.getSetting('provisioningData');
    }
    static clearToken(callback) {
        preferences.saveSetting('token', null, callback);
    }
    static isTokenValid(token) {
        if (!token.access_token)
            return false;
        const tokenParts = token.access_token.split('.');
        if (!tokenParts || tokenParts.length != 3)
            return false;
        const tokenArray = (0, internal_1.Base64ToArrayBufferEx)(tokenParts[1]);
        if (!tokenArray)
            return false;
        const strObj = new TextDecoder().decode(tokenArray);
        if (!strObj)
            return false;
        const tokenObj = JSON.parse(strObj);
        if (!tokenObj || !tokenObj.exp)
            return false;
        let d = tokenObj.exp;
        if (typeof tokenObj.exp !== 'number')
            return false;
        if (tokenObj.exp < 1000 * 1000 * 1000 * 1000) {
            d *= 1000;
        }
        if (d > 100 * 1000 * 1000 * 86400 * 1000 ||
            d < 100 * 1000 * 1000 * 86400 * 1000 * -1) {
            return false;
        }
        return true;
    }
    static getAccessToken(apiServer, deviceName, machineCode) {
        return new Promise(async (resolve, reject) => {
            var _a;
            const token = preferences.getSetting('token');
            if (!token) {
                logger.logMessage('Token not found in preferences. Calling server...');
                logger.logMessage('provisioning_code from policy: ' + ((_a = LStudent.policy) === null || _a === void 0 ? void 0 : _a.provisioning_code));
                const deviceID = internal_1.UserInfoRetriever.getDeviceID();
                deviceName = deviceName ? deviceName : internal_1.UserInfoRetriever.getDeviceName();
                const emailID = internal_1.UserInfoRetriever.getEmailAddr();
                let osType = internal_1.UserInfoRetriever.getOsTypeForProvisioning();
                if (!osType)
                    osType = internal_1.UserInfoRetriever.getOsType();
                const deviceType = internal_1.UserInfoRetriever.getDeviceType();
                try {
                    const provisioningData = await internal_1.Provisioning.doProvisioning(machineCode, deviceID, deviceName, emailID, osType, deviceType);
                    if (provisioningData.id && provisioningData.deviceID && provisioningData.orgID) {
                        pubsub_js_1.default.publish('onProvisionStatus', { provisioned: true });
                        preferences.saveSetting('provisioningData', provisioningData);
                        preferences.saveSetting('provisioningParams', { deviceName, machineCode });
                        this.getAccessTokenFromServer(apiServer, provisioningData.deviceID, provisioningData.orgID).then((accessToken) => {
                            pubsub_js_1.default.publish('onTokenStatus', { validToken: true });
                            logger.logMessage('Current time is: ' + Date.now());
                            logger.logMessage('Success returning from getAccessTokenFromServer()');
                            preferences.saveSetting('token', accessToken);
                            resolve(accessToken);
                        }).catch((err) => {
                            pubsub_js_1.default.publish('onTokenStatus', {
                                validToken: false,
                                error: err
                            });
                            logger.logMessage('Error calling getAccessTokenFromServer: ' + JSON.stringify(err));
                            reject(err);
                        });
                    }
                    else {
                        pubsub_js_1.default.publish('onProvisionStatus', {
                            provisioned: false,
                            error: internal_1.chrome.i18n.getMessage('provisioning_data_incomplete')
                                || 'Provisioning data incomplete'
                        });
                        reject('Provisioning data incomplete!');
                    }
                }
                catch (err) {
                    pubsub_js_1.default.publish('onProvisionStatus', {
                        provisioned: false,
                        error: err
                    });
                    logger.logMessage('Error doing provisioning: ' + JSON.stringify(err));
                    reject(err);
                }
            }
            else {
                pubsub_js_1.default.publish('onProvisionStatus', { provisioned: true });
                logger.logMessage('Token found in preferences: ' + JSON.stringify(token));
                if (this.isTokenValid(token)) {
                    pubsub_js_1.default.publish('onTokenStatus', { validToken: true });
                    resolve(token);
                }
                else {
                    logger.logMessage('Token is not valid. Obtaining new token...');
                    this.getNewAccessToken(apiServer).then((accessToken) => {
                        pubsub_js_1.default.publish('onTokenStatus', { validToken: true });
                        resolve(accessToken);
                    }).catch((err) => {
                        pubsub_js_1.default.publish('onTokenStatus', {
                            validToken: false,
                            error: err
                        });
                        logger.logError('getNewAccessToken exception: ' + err);
                        reject(err);
                    });
                }
            }
        });
    }
    static getNewAccessToken(apiServer) {
        return new Promise(async (resolve, reject) => {
            const provisioningData = preferences.getSetting('provisioningData');
            if (!provisioningData || !provisioningData.deviceID || !provisioningData.orgID) {
                const errMsg = 'DeviceID / OrgID not provided.';
                logger.logMessage(errMsg);
                reject(new Error(errMsg));
            }
            try {
                const accessToken = await this.getAccessTokenFromServer(apiServer, provisioningData.deviceID, provisioningData.orgID);
                logger.logMessage('Success returning from getAccessTokenFromServer()');
                preferences.saveSetting('token', accessToken);
                resolve(accessToken);
            }
            catch (err) {
                logger.logError('Error calling getAccessTokenFromServer: ' + JSON.stringify(err));
                reject(err);
            }
            ;
        });
    }
    static getAccessTokenFromServer(apiServer, deviceID, orgID) {
        logger.logMessage('(+)getAccessTokenFromServer() deviceID = ' + deviceID + ', orgID = ' + orgID);
        return new Promise((resolve, reject) => {
            const header = {
                alg: 'RS256',
                typ: 'JWT'
            };
            const iat = Math.round(Date.now() / 1000);
            preferences.saveSetting('iat', iat);
            const payload = {
                iss: deviceID,
                sub: orgID,
                aud: '/oauth/token',
                iat: iat
            };
            const grantTypeVal = 'urn:ietf:params:oauth:grant-type:jwt-bearer';
            internal_1.PKI.getJWT({ header: header, payload: payload }).then((signedToken) => {
                logger.logMessage('grant_type: ' + grantTypeVal);
                const params = {
                    grant_type: grantTypeVal,
                    assertion: signedToken
                };
                if (!apiServer.endsWith("/"))
                    apiServer += "/";
                internal_1.routeVerifier.verify(apiServer + internal_1.Endpoints.AccessTokenEndpoint, async (url) => {
                    logger.logMessage('Calling ' + url);
                    try {
                        const response = await internal_1.httpAPI.post(url, JSON.stringify(params));
                        const parseResponseBody = (body) => {
                            try {
                                return JSON.parse(body);
                            }
                            catch (e) {
                                logger.logError('getAccessTokenFromServer exception parsing JSON: ' + e);
                                return null;
                            }
                        };
                        try {
                            const responseText = await response.text();
                            if (response.status === 200) {
                                logger.logMessage('accessTokenCall response = ' + responseText);
                                const retObj = JSON.parse(responseText);
                                if (retObj !== null && retObj.access_token !== null && retObj.expires_in !== null) {
                                    resolve(internal_1.LSAToken.fromAny(retObj));
                                }
                                else {
                                    reject({ status: 500, message: 'Invalid response data' });
                                }
                            }
                            else if (response.status === 403) {
                                logger.logMessage('accessTokenCall response (403) = ' + responseText);
                                const retObj = parseResponseBody(responseText);
                                if (retObj !== null && (retObj.nextConnectTime || retObj.error_description)) {
                                    reject({
                                        endpoint: url,
                                        status: 403,
                                        nextConnectTime: retObj.nextConnectTime || retObj.error_description
                                    });
                                }
                            }
                            else if (response.status === 503) {
                                logger.logMessage('accessTokenCall response (503) = ' + responseText);
                                const retObj = parseResponseBody(responseText);
                                const nextConnectTime = (retObj === null || retObj === void 0 ? void 0 : retObj.unavailableUntil) || (retObj === null || retObj === void 0 ? void 0 : retObj.error_description);
                                reject({
                                    endpoint: url,
                                    status: 503,
                                    nextConnectTime
                                });
                            }
                            else {
                                logger.logError('accessTokenCall gave status ' + response.status);
                                reject({
                                    endpoint: url,
                                    status: response.status
                                });
                            }
                        }
                        catch (error) {
                            reject({ status: 500, message: 'Invalid response data' });
                        }
                    }
                    catch (error) {
                        logger.logError('accessTokenCall threw error on fetch: ' + error);
                        reject({
                            endpoint: url,
                            status: 0
                        });
                    }
                });
            }).catch((err) => {
                logger.logError('getAccessTokenFromServer exception: ' + err);
                reject(err);
            });
        });
    }
}
exports.AccessToken = AccessToken;
//# sourceMappingURL=accessToken.js.map