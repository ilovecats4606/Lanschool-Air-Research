"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Provisioning = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const defs_1 = require("./js/defs");
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
const preferences = new internal_1.StorageInterop();
const LStudent = new internal_1.LStudentInterop();
const reasonInsufficientLicenses = 'insufficientLicenses';
const reasonResourceNotFound = 'resourceNotFound';
class Provisioning {
    static formProvisioningErrorString(status, reason) {
        let str = internal_1.chrome.i18n.getMessage('provisioning_server_error_code') ||
            'Error calling provisioning endpoint. Server returned status {error_code}';
        if (!status)
            return str;
        str = str.replace('{error_code}', status.toString());
        let additionalInformation = internal_1.chrome.i18n.getMessage('provisioning_server_error_no_additional_information') || 'No additional information available.';
        if (status === 403) {
            if (reason === reasonInsufficientLicenses) {
                additionalInformation =
                    internal_1.chrome.i18n.getMessage('provisioning_server_error_insufficient_licenses_403') ||
                        'This organization is out of client licenses.';
            }
            else {
                additionalInformation =
                    internal_1.chrome.i18n.getMessage('provisioning_server_error_additional_information_403') ||
                        'The provisioning window may be closed.';
            }
        }
        else if (status === 404) {
            if (reason === reasonResourceNotFound) {
                additionalInformation = internal_1.chrome.i18n.getMessage('provisioning_server_error_resource_not_found_404') || 'Resource not found.';
            }
        }
        str = str.replace('{additional_information}', additionalInformation);
        return str;
    }
    static shouldHaltFromProvisioningError(status, reason) {
        return ((status === 404 || status === 403) &&
            (reason === reasonInsufficientLicenses || reason === reasonResourceNotFound));
    }
    static formCatchallErrorString() {
        return (internal_1.chrome.i18n.getMessage('provisioned_to_catchall_org') ||
            'This device is not currently provisioned to a valid organization.');
    }
    static hasValidProvision() {
        const provisioningData = preferences.getSetting('provisioningData');
        const provisioningParams = preferences.getSetting('provisioningParams');
        if (provisioningData &&
            provisioningParams &&
            provisioningData.hasOwnProperty('id') &&
            provisioningParams.hasOwnProperty('machineCode') &&
            provisioningParams.machineCode !== defs_1.CatchAllOrg) {
            return true;
        }
        else {
            return false;
        }
    }
    static async doProvisioning(machineCode, deviceID, deviceName, emailAddr, osType, deviceType) {
        const provisionURL = `${LStudent.apiServer}0/lsa/lanschool/clients/provision`;
        const publicKey = internal_1.PKI.publicPEM;
        if (!publicKey) {
            const msg = 'Cannot provision: No public key!';
            logger.logError(msg);
            pubsub_js_1.default.publish('onProvisioningAttempted');
            return Promise.reject({
                offline: false,
                error: msg
            });
        }
        const provObj = {
            code: machineCode,
            publicKey: publicKey,
            deviceID: deviceID,
            deviceName: deviceName,
            deviceType: deviceType,
            os: osType,
            userKey: ''
        };
        if (emailAddr) {
            provObj.userKey = emailAddr;
        }
        logger.logMessage(`Provisioning.doProvisioning calling ${provisionURL} with ` +
            JSON.stringify(provObj));
        try {
            const response = await internal_1.httpAPI.post(provisionURL, JSON.stringify(provObj));
            if ([200, 201].includes(response.status)) {
                const data = await response.json();
                logger.logMessage('provCall response = ' + JSON.stringify(data));
                // its not a default param provision
                if (data !== null && defs_1.CatchAllOrg !== machineCode) {
                    pubsub_js_1.default.publish('onProvisioningAttempted');
                    return Promise.resolve(internal_1.ProvisioningData.fromAny(data));
                }
                else {
                    pubsub_js_1.default.publish('onCatchAllProvisioning');
                    return Promise.reject({
                        offline: false,
                        error: Provisioning.formCatchallErrorString(),
                        halt: true
                    });
                }
            }
            else {
                logger.logMessage('provCall gave status ' + response.status);
                if (response.status == 0) {
                    return Promise.reject({
                        offline: true
                    });
                }
                else {
                    const data = await response.json();
                    logger.logError(JSON.stringify(data));
                    pubsub_js_1.default.publish('onProvisioningAttempted');
                    return Promise.reject({
                        offline: false,
                        error: Provisioning.formProvisioningErrorString(response.status, data === null || data === void 0 ? void 0 : data.reason),
                        halt: Provisioning.shouldHaltFromProvisioningError(response.status, data === null || data === void 0 ? void 0 : data.reason)
                    });
                }
            }
        }
        catch (error) {
            logger.logError(JSON.stringify(error));
            pubsub_js_1.default.publish('onProvisioningAttempted');
            return Promise.reject({
                offline: false,
                error: Provisioning.formCatchallErrorString(),
                halt: true
            });
        }
    }
}
exports.Provisioning = Provisioning;
//# sourceMappingURL=provisioning.js.map