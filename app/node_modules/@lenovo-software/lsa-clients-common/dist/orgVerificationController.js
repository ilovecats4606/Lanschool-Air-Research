"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgVerificationController = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const internal_1 = require("./internal");
let logger = new internal_1.LoggerInterop();
class OrgVerificationController {
    constructor() {
        this.subscriptionTokens = [];
        logger.logDebug('OrgVerificationController(+)');
        // this.contextMenuId = null; // TODO: Break user-selectable monitor re-enabling out into its own class
        internal_1.chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
            var _a;
            switch (request.message) {
                case 'UserAllowsMonitoring':
                    {
                        pubsub_js_1.default.publish('onUserAllowsMonitoring', {
                            startMonitoringWindow: false
                        });
                    }
                    break;
                case 'UserRejectsMonitoring':
                    {
                        pubsub_js_1.default.publish('onLeaveClass');
                        this.lastMonitoringWindowState = 'Self Close';
                        (_a = internal_1.LSAClient.getInstance().contextMenu) === null || _a === void 0 ? void 0 : _a.createMenuItem({
                            id: '0:allow-monitoring',
                            title: internal_1.chrome.i18n.getMessage('allow_monitoring'),
                            onClick: () => {
                                pubsub_js_1.default.publish('onUserAllowsMonitoring', {
                                    startMonitoringWindow: true
                                });
                            },
                            onError: () => { }
                        });
                    }
                    break;
                case 'MonitoringWindowState':
                    {
                        this.lastMonitoringWindowState = request.stateObj;
                    }
                    break;
                case 'RequestMonitoringWindowState': {
                    if (this.lastMonitoringWindowState) {
                        sendResponse(this.lastMonitoringWindowState);
                    }
                    else {
                        //initial RequestMonitoringWindowState request is received here and will result in the monitor dialog opening
                        sendResponse({
                            presentation: 'UserRequest',
                            param: internal_1.chrome.i18n.getMessage('your_teacher') ||
                                'Your teacher'
                        });
                    }
                }
            }
        });
        this.subscriptionTokens.push(pubsub_js_1.default.subscribe('onUserAllowsMonitoring', (msg, data) => {
            var _a;
            if (this.callback)
                this.callback(true);
            (_a = internal_1.LSAClient.getInstance().contextMenu) === null || _a === void 0 ? void 0 : _a.removeMenuItem('0:allow-monitoring');
            this.lastMonitoringWindowState = {
                presentation: 'ActiveMonitoring'
            };
            if (data && data.startMonitoringWindow) {
                this.showMonitoringWindow();
            }
        }));
        this.subscriptionTokens.push(pubsub_js_1.default.subscribe('onStopMonitoring', () => {
            var _a;
            logger.logMessage('OrgVerificationController.onStopMonitoring(+)');
            this.closeMonitoringWindow();
            (_a = internal_1.LSAClient.getInstance().contextMenu) === null || _a === void 0 ? void 0 : _a.removeMenuItem('0:allow-monitoring');
        }));
        this.subscriptionTokens.push(pubsub_js_1.default.subscribe('onLeaveClassPostProcess', () => {
            var _a, _b;
            (_a = internal_1.OptInParametersStore.getInstance()) === null || _a === void 0 ? void 0 : _a.setOrgVerified(false);
            (_b = internal_1.OptInParametersStore.getInstance()) === null || _b === void 0 ? void 0 : _b.setMonitoringOptInFlagValue(false);
            logger.logMessage('OrgVerificationController.onLeaveClassPostProcess(+)');
            this.closeMonitoringWindow();
        }));
    }
    static getInstance() {
        if (!OrgVerificationController.instance) {
            OrgVerificationController.instance = new OrgVerificationController();
        }
        return OrgVerificationController.instance;
    }
    destroy() {
        this.subscriptionTokens.forEach((subscription) => {
            logger.logDebug('OrgVerificationController.destroy(): Destroying subscription token ' +
                subscription);
            pubsub_js_1.default.unsubscribe(subscription);
        });
        this.subscriptionTokens = [];
    }
    closeMonitoringWindow() {
        this.lastMonitoringWindowState = 'Self Close';
        internal_1.chrome.runtime.sendMessage({ message: 'CloseMonitoringStatusWindow' });
        if (this.contextMenuId) {
            internal_1.chrome.contextMenus.remove(this.contextMenuId);
            this.contextMenuId = undefined;
        }
    }
    setCallback(callback) {
        this.callback = callback;
    }
    handleOrgVerification(orgRetriever) {
        orgRetriever
            .retrieveOrgVerification()
            .then((orgModel) => {
            var _a, _b;
            pubsub_js_1.default.publish('onOrgVerification', orgModel);
            if (orgModel && orgModel.isVerified) {
                (_a = internal_1.OptInParametersStore.getInstance()) === null || _a === void 0 ? void 0 : _a.setOrgVerified(true);
                if (this.callback)
                    this.callback(true);
            }
            else {
                (_b = internal_1.OptInParametersStore.getInstance()) === null || _b === void 0 ? void 0 : _b.setOrgVerified(false);
                this.startShowMonitoringWindow(0);
            }
        })
            .catch((err) => {
            logger.logError('handleOrgVerification: Error retrieving org data: ' + err);
        });
    }
    handleRequireDeviceMonitoringOptIn() {
        var _a;
        (_a = internal_1.OptInParametersStore.getInstance()) === null || _a === void 0 ? void 0 : _a.setMonitoringOptInFlagValue(true);
        this.startShowMonitoringWindow(0);
    }
    startShowMonitoringWindow(iterationsForTimeout) {
        if (iterationsForTimeout > 50) {
            logger.logError(`OrgVerificationController.startShowMonitoringWindow() waited too long for monitoring window to enter proper state!`);
        }
        else if (this.lastMonitoringWindowState && this.lastMonitoringWindowState !== 'Self Close') {
            // We must wait until the window is in a proper state for us to start showing it. This check is necessary
            // because in the case of stealing the student from another class, the window will get closed asynchronously,
            // perhaps just after we opened it. So we must look for either a null state (in case the window has not yet
            // been opened) or a "Self Close" (in case the window was just closed like when the student is stolen from another
            // class.)
            logger.logDebug(`OrgVerificationController.startShowMonitoringWindow() waiting (${iterationsForTimeout})... (${JSON.stringify(this.lastMonitoringWindowState)})`);
            setTimeout(() => this.startShowMonitoringWindow(++iterationsForTimeout), 200);
            return;
        }
        logger.logMessage(`OrgVerificationController.startShowMonitoringWindow(): this.lastMonitoringState: (${JSON.stringify(this.lastMonitoringWindowState)})`);
        this.lastMonitoringWindowState = null;
        this.showMonitoringWindow();
    }
    showMonitoringWindow() {
        if (this.lastMonitoringWindowState !== 'Self Close') {
            (0, internal_1.showMonitoringDialog)({
                orgVerification: this
            });
        }
    }
}
exports.OrgVerificationController = OrgVerificationController;
OrgVerificationController.instance = null;
//# sourceMappingURL=orgVerificationController.js.map