"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageInterop = void 0;
const internal_1 = require("../../internal");
// This class provides support for original JS client
class StorageInterop {
    constructor() {
        this._storage = null;
    }
    get storage() {
        if (!this._storage) {
            if (internal_1.LSAClient) {
                this._storage = internal_1.LSAClient.getInstance().storage;
            }
        }
        return this._storage;
    }
    async removeSetting(obj, callback) {
        internal_1.LSAClient.getInstance().logger.logDebug(`StorageInterop.removeSetting(): Removing keys ${JSON.stringify(obj)}`);
        let keys = new Array();
        // The interop can take an array of keys or a single key.
        if (typeof obj === 'string') {
            keys.push(obj);
        }
        else if (Array.isArray(obj)) {
            keys = obj;
        }
        for (let i = 0; i < keys.length; i++) {
            try {
                await this.saveSetting(keys[i], undefined, null);
            }
            catch (err) {
                // Who cares (me)
                internal_1.LSAClient.getInstance().logger.logError('StorageInterop.removeSetting() error: ' + err);
            }
        }
        if (callback) {
            callback();
        }
    }
    keysForbiddenToPrint() {
        return ['privateJWK'];
    }
    getDebugString(key, value) {
        return `key[${key}] = ${(this.keysForbiddenToPrint().includes(key) && value) ? '****' : JSON.stringify(value)}`;
    }
    getSetting(key) {
        const data = this.getSettingImpl(key);
        internal_1.LSAClient.getInstance().logger.logDebug(`StorageInterop.getSetting(): ${this.getDebugString(key, data)}`);
        return data;
    }
    getSettingImpl(key) {
        if (key === 'provisioningData') {
            return this.storage ? this.storage.loadProvisioningData() : null;
        }
        if (key === 'token') {
            return this.storage ? this.storage.loadToken() : null;
        }
        if (key === 'provisioningParams') {
            return this.storage ? this.storage.loadProvisioningParams() : null;
        }
        if (key === 'privateJWK') {
            return this.storage ? this.storage.loadPrivateKey() : null;
        }
        if (key === 'publicPEM') {
            return this.storage ? this.storage.loadPublicKey() : null;
        }
        throw new Error("Storage setting '" + key + "' not implemented.");
    }
    async saveSetting(key, value, callback) {
        await this.saveSettingImpl(key, value);
        internal_1.LSAClient.getInstance().logger.logDebug(`StorageInterop.saveSetting(): ${this.getDebugString(key, value)}`);
        if (callback) {
            callback();
        }
    }
    async saveSettingImpl(key, value) {
        if (!this.storage) {
            throw new Error('StorageInterop.saveSetting(): No storage interface defined.');
        }
        if (key === 'provisioningData') {
            await this.storage.saveProvisioningData(value);
        }
        else if (key === 'token') {
            await this.storage.saveToken(value);
        }
        else if (key === 'provisioningParams') {
            await this.storage.saveProvisioningParams(value);
        }
        else if (key === 'privateJWK') {
            await this.storage.savePrivateKey(value);
        }
        else if (key === 'publicPEM') {
            await this.storage.savePublicKey(value);
        }
        else if (key === 'iat') {
            // meh. No one uses this.
        }
        else {
            throw new Error("Storage setting '" + key + "' not implemented.");
        }
    }
}
exports.StorageInterop = StorageInterop;
//# sourceMappingURL=storageInterop.js.map