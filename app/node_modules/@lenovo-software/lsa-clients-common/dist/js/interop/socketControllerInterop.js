"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketControllerInterop = void 0;
const internal_1 = require("../../internal");
class SocketControllerInterop {
    constructor() {
        this.lsaClient = internal_1.LSAClient.getInstance();
        this.socketControllerJS = new internal_1.SocketController({
            LStudent: {
                policy: {
                    api_server: this.lsaClient.clientParams.apiServerForHTTPS,
                    provisioning_code: this.lsaClient.clientParams.hotProvisioningCode.length >
                        0
                        ? this.lsaClient.clientParams.hotProvisioningCode
                        : this.lsaClient.clientParams.provisioningCode
                },
                displayName: this.lsaClient.storage.loadDisplayName(),
                emailAddr: this.lsaClient.storage.loadEmailAddr(),
                machineName: this.lsaClient.storage.loadDeviceName()
            },
            clientVersion: this.lsaClient.storage.getClientVersion(),
            metricAccumulator: internal_1.MetricAccumulator.getInstance(),
            socketAgentHeader: this.lsaClient.getAgentVersionHeaderString()
        });
    }
    async startConnection() {
        // Depending on how we want to use this, we could turn this into a promise. As it is right now,
        // the idea is that the caller would run this to start, then wait for an event to do whatever the next
        // thing is.
        let connectionParams = {
            server: '',
            apiServer: this.lsaClient.clientParams.apiServerForHTTPS,
            deviceName: this.lsaClient.clientParams.deviceName,
            socketTransportOpts: await this.lsaClient.networkTransportOpts.getSupportedSocketTransports()
        };
        // Calling setup PKI here because the only way it runs otherwise is when the original preferences
        // object completes its load. Since we now use an abstracted storage API, that publish will
        // never occur and the PKI will not be setup.
        await internal_1.PKIInterop.setupPKI();
        this.socketControllerJS.startConnection(connectionParams);
    }
    setClassSocketDestination(teacherRoom) {
        this.socketControllerJS.setClassSocketDestination(teacherRoom);
    }
    joinRoom(currentClassData, osVersionString) {
        this.socketControllerJS.joinRoom(currentClassData, osVersionString);
    }
    leaveRoom(leaveObj) {
        this.socketControllerJS.leaveRoom(leaveObj);
    }
    doClassLookup() {
        try {
            const emailAddr = this.lsaClient.storage.loadEmailAddr();
            const studentName = this.lsaClient.storage.loadDisplayName();
            const loginName = this.lsaClient.storage.loadLoginName();
            let domainName = '';
            try {
                domainName = internal_1.Utils.getEmailDomainFromEmailAddr(emailAddr);
            }
            catch (e) {
                this.lsaClient.logger.logError('SocketControllerInterop.getEmailDomainFromEmailAddr error: ' +
                    JSON.stringify(e));
            }
            const deviceID = internal_1.UserInfoRetriever.getDeviceID();
            const machineName = this.lsaClient.storage.loadDeviceName();
            this.socketControllerJS.lookup({
                emailAddr: emailAddr,
                studentName: studentName,
                loginName: loginName,
                domainName: domainName,
                deviceID: deviceID,
                machineName: machineName,
                clientVersion: '',
                classSocketSupport: true
            });
        }
        catch (err) {
            this.lsaClient.logger.logError('SocketControllerInterop.lookup(): Error calling lookup: ' +
                JSON.stringify(err));
        }
    }
    // Called by telemetry.js
    postTelemetryMessage(telemetryObj) {
        this.socketControllerJS.postTelemetryMessage(telemetryObj);
    }
    postIntellitaskAssesmentMessage(assessmentMessage) {
        this.socketControllerJS.postIntellitaskAssesmentMessage(assessmentMessage);
    }
    postMessageFromFactory(messageFactory) {
        this.socketControllerJS.postMessageFromFactory(messageFactory);
    }
    postChatMessageToTeacher(chatMessage) {
        // Because we are the interop class, we do the translation here until the controller
        // and socket are rewritten in TS to use the proper ChatMessage model
        this.socketControllerJS.postChatMessage(chatMessage);
    }
    postRaiseHandStatusToTeacher(raiseHandStatusMessage) {
        // Because we are the interop class, we do the translation here until the controller
        // and socket are rewritten in TS to use the proper RaiseHandStatusMessage model
        this.socketControllerJS.postRaiseHand(raiseHandStatusMessage, this.lsaClient.storage.loadEmailAddr());
    }
    postCurrentScreenMessage(currentScreenRequestResponse) {
        this.socketControllerJS.postCurrentScreenMessage({
            width: currentScreenRequestResponse.width,
            height: currentScreenRequestResponse.height,
            data: currentScreenRequestResponse.imgData,
            dataType: 'base64',
            activeTabFailure: false,
            imgData: ''
        });
    }
    postShareStudentScreenResponse(shareStudentScreenData) {
        this.socketControllerJS.postShareStudentScreenResponse(shareStudentScreenData);
    }
    postStopStudentScreenBroadcast(stopStudentScreenData) {
        this.socketControllerJS.postStopStudentScreenBroadcast(stopStudentScreenData);
    }
    setLeaveClassCallback(callback) {
        this.socketControllerJS.setLeaveClassCallback(callback);
    }
}
exports.SocketControllerInterop = SocketControllerInterop;
//# sourceMappingURL=socketControllerInterop.js.map