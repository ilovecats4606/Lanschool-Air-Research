"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunningAppsInstrumentation = exports.BatteryStatusPoller = exports.OtmCurrentTabsInterop = exports.CurrentTabsInterop = exports.ScreenCaptureInterop = exports.MainPageStudentInterop = exports.TelemetryInterop = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const defs_1 = require("../defs");
const internal_1 = require("../../internal");
const logger = new internal_1.LoggerInterop();
// This class is used to control with the Telemetry JS object.
// Because Telemetry JS does not understand async/await, this class
// will do that by retrieving the latest stuff from the caller and making it available
// to Telemetry JS.
class TelemetryInterop {
    constructor() {
        this.currentTabs = new CurrentTabsInterop(this);
        this.screenCapture = new ScreenCaptureInterop();
        this.batteryStatus = new BatteryStatusPoller();
        this.mainPageStudent = new MainPageStudentInterop(this.batteryStatus);
        this.runningApps = new RunningAppsInstrumentation();
        this.pollingTask = new internal_1.PollingTask();
        this.telemetry = new internal_1.Telemetry({
            mainPageStudent: this.mainPageStudent,
            sioMsg: internal_1.LSAClient.getInstance().socketController,
            currentTabs: this.currentTabs,
            screenCapture: this.screenCapture,
            pollingTask: this.pollingTask,
            runningAppsInstrumentation: this.runningApps,
            dateImpl: Date
        });
    }
    static getInstance() {
        if (!TelemetryInterop.instance) {
            TelemetryInterop.instance = new TelemetryInterop();
        }
        return TelemetryInterop.instance;
    }
}
exports.TelemetryInterop = TelemetryInterop;
class MainPageStudentInterop {
    constructor(batteryStatusPoller) {
        this.batteryStatusPoller = batteryStatusPoller;
        this.lastURL = new internal_1.CurrentWebsite();
    }
    get battery() {
        return this.batteryStatusPoller.batteryStatus;
    }
    // Called by JS
    isStudentInShowTeacherMode() {
        // TODO when supporting show teacher
        // Yes, we need to fix this but I'm tired of seeing it in the logs.
        // logger.logWarning(
        //     'MainPageStudentInterop.isStudentInShowTeacherMode(): A note to remind you that this is not supported yet!'
        // );
        return false;
    }
    // Called by JS
    isStudentWaitingForFullScreenPermission() {
        const screenCapture = internal_1.LSAClient.getInstance().telemetryInstrumentation.screenCapture;
        if (screenCapture.isWaitingForFullScreenPermission) {
            return screenCapture.isWaitingForFullScreenPermission();
        }
        return false;
    }
    // tslint:disable-next-line: no-empty
    startPollingBattery() {
        this.batteryStatusPoller.pollBattery(60000);
    }
    stopPollingBattery() {
        this.batteryStatusPoller.stopBatteryPolling();
    }
}
exports.MainPageStudentInterop = MainPageStudentInterop;
const ACTIVE_TAB_STRING = 'Active Tab';
const FULL_SCREEN_STRING = 'Full Screen';
const OriginalThumbnailCapturePeriod = 10000;
class ScreenCaptureInterop {
    constructor() {
        this.latestImage = null;
        this.thumbnailParams = null;
        pubsub_js_1.default.subscribe('onLeaveClassPostProcess', () => {
            this.clearThumbnailBuffer();
        });
        pubsub_js_1.default.subscribe('onHeartbeatTimeout', () => {
            this.clearThumbnailBuffer();
        });
        pubsub_js_1.default.subscribe('onConnectionStateChange', (msg, data) => {
            if (data && data.connected != defs_1.ConnectionStateEnum.Connected)
                this.clearThumbnailBuffer();
        });
    }
    get thumbnailOK() {
        if (this.latestImage &&
            this.latestImage.size &&
            this.latestImage.size.width > 0 &&
            this.latestImage.size.height > 0) {
            return true;
        }
        return false;
    }
    get thumbnailObj() {
        if (this.latestImage) {
            return ScreenCaptureInterop.translateThumbnailImageToJS(this.latestImage);
        }
        return null;
    }
    clearThumbnailBuffer() {
        this.latestImage = null;
    }
    async setThumbnailParams(params) {
        this.thumbnailParams = params;
    }
    currentThumbnailImageSourceIsActiveTab() {
        if (!this.latestImage || !this.latestImage.source)
            return false;
        return this.latestImage.source === internal_1.ThumbnailSource.ActiveTab;
    }
    async callInstrumentation() {
        if (!this.thumbnailParams) {
            throw new Error('thumbnailParams not defined!');
        }
        const thumbnailRequest = ScreenCaptureInterop.translateThumbnailParamsToThumbnailRequest(this.thumbnailParams);
        const instrumentation = internal_1.LSAClient.getInstance().telemetryInstrumentation.screenCapture;
        if (instrumentation) {
            this.latestImage = await instrumentation.getThumbnail(thumbnailRequest);
        }
    }
    // This function is unnecessary since the implementor will decide.
    // tslint:disable-next-line: no-empty
    decideFormat(formatPref) {
        if (!formatPref)
            return 'JPG';
        const formatsCapable = ['JPG', 'PNG'];
        formatPref.forEach(function (element) {
            if (formatsCapable.indexOf(element) >= 0)
                return element;
        });
    }
    static translateThumbnailParamsToThumbnailRequest(params) {
        const ret = new internal_1.ThumbnailRequest();
        ret.format = ScreenCaptureInterop.translateFormatStringArrayToEnum(params.format);
        ret.source =
            ScreenCaptureInterop.translateSourceStringToThumbnailSource(params.source);
        ret.size = new internal_1.ThumbnailSize();
        ret.size.width = params.width || 160;
        ret.size.height = params.height || 100;
        ret.skipResize = !!params.skipResize;
        return ret;
    }
    static translateThumbnailImageToJS(latestImage) {
        var _a;
        const ret = {
            format: latestImage.type,
            size: {
                width: latestImage.size
                    ? latestImage.size.width
                    : internal_1.DEFAULT_THUMBNAIL_WIDTH,
                height: latestImage.size
                    ? latestImage.size.height
                    : internal_1.DEFAULT_THUMBNAIL_HEIGHT
            },
            image: {
                data: latestImage.image,
                type: latestImage.type
            }
        };
        if (latestImage.source !== internal_1.ThumbnailSource.Unknown) {
            ret.image.source =
                ScreenCaptureInterop.translateThumbnailSourceToString((_a = latestImage.source) !== null && _a !== void 0 ? _a : internal_1.ThumbnailSource.Unknown);
        }
        return ret;
    }
    static translateFormatStringArrayToEnum(formatPref) {
        const ret = new Array();
        for (let i = 0; i < formatPref.length; i++) {
            switch (formatPref[i]) {
                case 'JPG': {
                    ret.push(internal_1.ThumbnailFormat.JPG);
                    break;
                }
                case 'PNG': {
                    ret.push(internal_1.ThumbnailFormat.PNG);
                    break;
                }
            }
        }
        return ret;
    }
    static translateSourceStringToThumbnailSource(source) {
        const ret = internal_1.ThumbnailSource.Unknown;
        if (!source || source.length < 1) {
            return ret;
        }
        switch (source) {
            case ACTIVE_TAB_STRING: {
                return internal_1.ThumbnailSource.ActiveTab;
            }
            case FULL_SCREEN_STRING: {
                return internal_1.ThumbnailSource.FullScreen;
            }
        }
        return ret;
    }
    static translateThumbnailSourceToString(source) {
        switch (source) {
            case internal_1.ThumbnailSource.ActiveTab: {
                return ACTIVE_TAB_STRING;
            }
            case internal_1.ThumbnailSource.FullScreen: {
                return FULL_SCREEN_STRING;
            }
        }
        return '';
    }
}
exports.ScreenCaptureInterop = ScreenCaptureInterop;
class CurrentTabsInterop {
    constructor(telemetryInterop) {
        this.telemetryInterop = telemetryInterop;
        this.tabs = new Array();
    }
    async callInstrumentation() {
        const instrumentation = internal_1.LSAClient.getInstance().telemetryInstrumentation
            .browserInstrumentation;
        if (instrumentation) {
            try {
                this.tabs = await instrumentation.getCurrentBrowserTabs();
            }
            catch (err) {
                logger.logError('CurrentTabsInterop getCurrentBrowserTabs exception: ' + err);
            }
            try {
                this.telemetryInterop.mainPageStudent.lastURL =
                    await instrumentation.getCurrentWebsite();
            }
            catch (err) {
                logger.logError('CurrentTabsInterop getCurrentWebsite exception: ' + err);
            }
        }
    }
    supportsBrowserTabsToTelemetry() {
        const instrumentation = internal_1.LSAClient.getInstance().telemetryInstrumentation
            .browserInstrumentation;
        if (instrumentation)
            return instrumentation.supportsBrowserTabsToTelemetry();
        return false;
    }
}
exports.CurrentTabsInterop = CurrentTabsInterop;
class OtmCurrentTabsInterop {
    constructor() {
        this.otmBrowserTabs = {
            tabs: []
        };
    }
    async callInstrumentation() {
        const instrumentation = internal_1.LSAClient.getInstance().otmBrowserInstrumentation;
        if (instrumentation) {
            this.otmBrowserTabs = await instrumentation.getCurrentBrowserTabs();
        }
    }
}
exports.OtmCurrentTabsInterop = OtmCurrentTabsInterop;
class BatteryStatusPoller {
    constructor() {
        this.batteryStatus = new internal_1.BatteryStatus();
        this.pollingHandle = null;
        pubsub_js_1.default.subscribe('onLeaveClassPostProcess', () => {
            this.stopBatteryPolling();
        });
        pubsub_js_1.default.subscribe('onHeartbeatTimeout', () => {
            this.stopBatteryPolling();
        });
        pubsub_js_1.default.subscribe('onConnectionStateChange', (msg, data) => {
            if (data && data.connected != defs_1.ConnectionStateEnum.Connected)
                this.stopBatteryPolling();
        });
    }
    async callInstrumentation() {
        logger.logInfo('BatteryStatusPoller.callInstrumentation(+)');
        const instrumentation = internal_1.LSAClient.getInstance().telemetryInstrumentation
            .batteryInstrumentation;
        if (instrumentation) {
            const batteryStatus = await instrumentation.getCurrentBatteryStatus();
            //we need to divide the battery level by 100 here, without mutating the original BatteryStatus
            this.batteryStatus = new internal_1.BatteryStatus();
            this.batteryStatus.level = batteryStatus.level / 100;
            this.batteryStatus.charging = batteryStatus.charging;
            this.batteryStatus.dischargingTime = batteryStatus.dischargingTime;
        }
    }
    async pollBattery(period) {
        this.stopBatteryPolling();
        await this.callInstrumentation();
        this.pollingHandle = setTimeout(async () => {
            this.pollBattery(period);
        }, period);
    }
    stopBatteryPolling() {
        if (this.pollingHandle) {
            clearTimeout(this.pollingHandle);
            this.pollingHandle = null;
        }
    }
}
exports.BatteryStatusPoller = BatteryStatusPoller;
class RunningAppsInstrumentation {
    constructor() {
        this.runningApps = new Array();
    }
    async callInstrumentation() {
        const instrumentation = internal_1.LSAClient.getInstance().telemetryInstrumentation
            .runningAppInstrumentation;
        if (instrumentation) {
            try {
                this.runningApps = await instrumentation.getRunningApps();
            }
            catch (err) {
                logger.logError('RunningAppsInstrumentation.callInstrumentation exception calling instrumentation: ' +
                    err);
            }
        }
    }
}
exports.RunningAppsInstrumentation = RunningAppsInstrumentation;
//# sourceMappingURL=telemetryInterop.js.map