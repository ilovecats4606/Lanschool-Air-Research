"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricReporter = exports.MetricAccumulator = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const defs_1 = require("./defs");
const internal_1 = require("../internal");
function roughSizeOfObject(object) {
    return object ? JSON.stringify(object).length : 0;
}
function getThumbnailFromTelemetry(obj) {
    if (!obj.hasOwnProperty('payload')) {
        // obj does not contain payload
        return null;
    }
    if (typeof obj.payload !== 'string') {
        return null;
    }
    let payload = JSON.parse(obj.payload);
    if (!payload ||
        !payload.currentTelemetryMessage ||
        !payload.currentTelemetryMessage.thumbnail ||
        !payload.currentTelemetryMessage.thumbnail.image ||
        !payload.currentTelemetryMessage.thumbnail.image.data) {
        // obj does not contain required object path
        return null;
    }
    return payload.currentTelemetryMessage.thumbnail.image.data;
}
class CountTotal {
    constructor() {
        this.currentValue = 0;
    }
    accumulate(obj) {
        this.currentValue += roughSizeOfObject(obj);
        //console.log('Metric - CountTotal: ' + roughSizeOfObject(obj));
    }
    report() {
        return this.currentValue;
    }
    reset() {
        this.currentValue = 0;
    }
}
class CountPerMinute {
    constructor() {
        this.totalBytes = 0;
        this.startTime = 0;
    }
    accumulate(obj) {
        this.totalBytes += roughSizeOfObject(obj);
        if (this.startTime === 0) {
            this.startTime = Date.now();
        }
    }
    report() {
        if (this.startTime === 0) {
            return 0;
        }
        const currentTime = Date.now();
        let elapsedTimeMS = currentTime - this.startTime;
        if (0 === elapsedTimeMS) {
            elapsedTimeMS = 1;
        }
        const elapsedTime = elapsedTimeMS / 1000;
        //console.log('Metric.report(): elapsed time: ' + elapsedTime);
        return (this.totalBytes * 60) / elapsedTime;
    }
    reset() {
        this.totalBytes = 0;
        this.startTime = 0;
    }
}
class Metric_CounterBase {
    constructor() {
        this.counter = new CountTotal();
    }
    accumulate(obj) {
        this.counter.accumulate(obj);
    }
    report() {
        return this.counter.report();
    }
    reset() {
        this.counter.reset();
    }
}
class Metric_CounterPerMinuteBase {
    constructor() {
        this.counter = new CountPerMinute();
    }
    accumulate(obj) {
        this.counter.accumulate(obj);
    }
    report() {
        return this.counter.report();
    }
    reset() {
        this.counter.reset();
    }
}
class Metric_ThumbnailBytesSinceLastReport extends Metric_CounterBase {
    constructor() {
        super();
    }
    accumulate(obj) {
        const thumbnail = getThumbnailFromTelemetry(obj);
        if (thumbnail) {
            this.counter.accumulate(thumbnail);
        }
    }
}
class Metric_TotalBytesSinceLastReport extends Metric_CounterBase {
    constructor() {
        super();
    }
}
class Metric_ThumbnailBytesPerMinute extends Metric_CounterPerMinuteBase {
    constructor() {
        super();
    }
    accumulate(obj) {
        const thumbnail = getThumbnailFromTelemetry(obj);
        if (thumbnail) {
            this.counter.accumulate(thumbnail);
        }
    }
}
class Metric_TotalBytesPerMinute extends Metric_CounterPerMinuteBase {
    constructor() {
        super();
    }
}
class Metric_ErrorCountSinceLastReport {
    constructor() {
        this.counter = 0;
    }
    accumulate(obj) {
        if (obj &&
            obj.hasOwnProperty('errorCount')) {
            this.counter += obj.errorCount;
        }
    }
    report() {
        return this.counter;
    }
    reset() {
        this.counter = 0;
    }
}
class MetricCounterModel {
    constructor(name, counter) {
        this.name = name;
        this.counter = counter;
    }
}
class MetricAccumulator {
    constructor(roundFunc) {
        this.roundFunc = roundFunc;
        this.counters = [
            new MetricCounterModel("lsa/device/thumbnail/bytes", new Metric_ThumbnailBytesSinceLastReport()),
            new MetricCounterModel("lsa/device/bytes", new Metric_TotalBytesSinceLastReport()),
            new MetricCounterModel("lsa/device/thumbnail/rate", new Metric_ThumbnailBytesPerMinute()),
            new MetricCounterModel("lsa/device/rate", new Metric_TotalBytesPerMinute()),
            new MetricCounterModel("lsa/device/errors", new Metric_ErrorCountSinceLastReport())
        ];
        this.roundFunc = roundFunc;
        if (!this.roundFunc) {
            this.roundFunc = (num) => {
                return Math.round(num);
            };
        }
    }
    static getInstance() {
        if (!MetricAccumulator.instance) {
            MetricAccumulator.instance = new MetricAccumulator();
        }
        return MetricAccumulator.instance;
    }
    accumulate(obj) {
        // Iterate through the chain of responsibility and accumulate for all counters
        for (let i = 0; i < this.counters.length; i++) {
            this.counters[i].counter.accumulate(obj);
        }
    }
    accumulateError(obj) {
        for (let i = 0; i < this.counters.length; i++) {
            if (this.counters[i].counter instanceof Metric_ErrorCountSinceLastReport) {
                this.counters[i].counter.accumulate(obj);
            }
        }
    }
    buildMetricObject(i, additionalAttributesCallback) {
        const metricObj = {
            metricName: this.counters[i].name,
            when: Date.now(),
            //@ts-ignore
            value: this.roundFunc(this.counters[i].counter.report())
        };
        if (!additionalAttributesCallback) {
            return metricObj;
        }
        let additionalAttributes = {};
        additionalAttributes = additionalAttributesCallback();
        for (const prop in additionalAttributes) {
            if (!metricObj.hasOwnProperty(prop)) {
                metricObj[prop] = JSON.parse(JSON.stringify(additionalAttributes[prop]));
            }
        }
        return metricObj;
    }
    report(additionalAttributesCallback) {
        // Iterate through the chain of responsibility and accumulate for all counters
        const retObj = [];
        for (let i = 0; i < this.counters.length; i++) {
            retObj.push(this.buildMetricObject(i, additionalAttributesCallback));
            // console.log('MetricAccumulator.report(): ' + this.counters[i].name + ": " + retObj[this.counters[i].name]);
            this.counters[i].counter.reset();
        }
        return retObj;
    }
}
exports.MetricAccumulator = MetricAccumulator;
class MetricReporterConfig {
    constructor(configEndpoint) {
        this.configEndpoint = configEndpoint;
        this.configEndpoint = configEndpoint;
    }
    getReportingInterval(tokenObj) {
        return new Promise((resolve) => {
            // DJB - 2/24/2023
            // We are removing XMLHttpRequest.js from the library because we were only keeping it
            // around to be backwards compatible with the original Chromebook implementation in the common
            // client code. Now that fetch() is being used everywhere in lieu of XHR, this is the only
            // remaining place where XHR is used. We're not using metrics at this time so be
            // advised that this should be switched over to use fetch().
            let xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (xhr.readyState == XMLHttpRequest.DONE) {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        let config = JSON.parse(xhr.responseText);
                        if (config && config.hasOwnProperty('sendInterval')) {
                            resolve(config.sendInterval);
                        }
                        else {
                            resolve(0);
                        }
                    }
                    else {
                        resolve(0);
                    }
                }
            };
            xhr.open('POST', this.configEndpoint, true);
            xhr.setRequestHeader("Authorization", tokenObj.access_token);
            xhr.setRequestHeader("Content-type", "application/json");
            xhr.send(JSON.stringify({
                configName: "socket"
            }));
        });
    }
}
class MetricReporter {
    constructor(obj) {
        this.apiServer = '';
        this.deviceId = '';
        this.provisioningCode = '';
        this.reportingEndpoint = '';
        this.classId = '';
        this.shouldBeRunning = false;
        this.logger = new internal_1.LoggerInterop();
        if (!obj.apiServer ||
            obj.apiServer.length === 0 ||
            !obj.accumulator ||
            !obj.deviceId ||
            !obj.provisioningCode) {
            this.logger.logError('MetricReporter(+): Missing parameters.  Reporting is now disabled');
            return;
        }
        this.apiServer = obj.apiServer;
        this.deviceId = obj.deviceId;
        this.provisioningCode = obj.provisioningCode;
        this.reportingEndpoint = this.resolveEndpoint(defs_1.MetricReporterReportingEndpoint);
        this.taskTimeout = -1;
        this.classId = '';
        this.reportingConfig = new MetricReporterConfig(this.resolveEndpoint(defs_1.MetricReporterConfigEndpoint));
        this.accumulator = obj.accumulator;
        this.shouldBeRunning = false;
        pubsub_js_1.default.subscribe('onJoinClassPostProcess', (msg, data) => {
            this.shouldBeRunning = true;
            if (data &&
                data.hasOwnProperty('classID')) {
                this.classId = data.classID;
            }
            this.run();
        });
        pubsub_js_1.default.subscribe('onLeaveClassPostProcess', () => {
            this.shouldBeRunning = false;
            this.classId = '';
            this.stop();
        });
    }
    resolveEndpoint(endpoint) {
        if (!this.apiServer || this.apiServer.length === 0) {
            throw new Error('MetricReporter.resolveEndpoint(): Missing API server.');
        }
        if (!this.apiServer.endsWith('/')) {
            this.apiServer += '/';
        }
        return this.apiServer + endpoint;
    }
    buildMetricPostObject(params) {
        if (!params.report) {
            throw new Error('MetricReporter.buildMetricObject(): Missing report parameter.');
        }
        return [{
                optional: this.optionalData(),
                events: params.report
            }];
    }
    optionalData() {
        return {
            classId: this.classId || ''
        };
    }
    // Once this is started it is designed to never stop until the class is dismissed.
    // It will get the reporting interval from the server every five minutes.
    async run() {
        if (!this.shouldBeRunning) {
            this.logger.logMessage('MetricReporter.run(): Not supposed to be running.');
            this.stop();
            return;
        }
        let tokenObj = {};
        try {
            tokenObj = await this.getAccessToken();
        }
        catch (err) {
            this.logger.logError('MetricReporter.run(): Failed to get access token: ' + JSON.stringify(err));
            return;
        }
        let reportingInterval = 0;
        try {
            reportingInterval = await this.reportingConfig.getReportingInterval(tokenObj);
        }
        catch (err) {
            this.logger.logError('MetricReporter.run(): Failed to get reporting interval: ' + JSON.stringify(err));
        }
        this.logger.logMessage('MetricReporter.run(): Reporting interval = ' + reportingInterval);
        if (reportingInterval && reportingInterval >= defs_1.MetricReporterMinimumReportingInterval) {
            this.taskTimeout = setTimeout(() => {
                this.stop();
                const reportObj = this.accumulator.report();
                const toSend = this.buildMetricPostObject({
                    report: reportObj
                });
                this.getAccessToken()
                    .then((tokenObj) => {
                    this.logger.logMessage('MetricReporter.run(): Issuing report...');
                    this.postReport(toSend, tokenObj)
                        .then(() => {
                        this.logger.logMessage('MetricReporter.run(): Completed issuing report...');
                        this.run();
                    })
                        .catch((err) => {
                        this.logger.logError('MetricReporter.run(): Error issuing report: ' + JSON.stringify(err));
                        this.run();
                    });
                })
                    .catch(() => {
                    this.logger.logError('MetricReporter.postReport(): Failed to retrieve access token. No metric report will be posted.');
                    // reject();
                });
            }, reportingInterval);
        }
        else {
            this.logger.logMessage('MetricReporter.run(): Invalid reporting interval: "' + reportingInterval + '". Checking again in ' + defs_1.MetricReporterCheckInterval + 'ms.');
            this.taskTimeout = setTimeout(() => {
                this.stop();
                this.run();
            }, defs_1.MetricReporterCheckInterval);
        }
    }
    stop() {
        if (this.taskTimeout !== -1) {
            clearTimeout(this.taskTimeout);
            this.taskTimeout = -1;
        }
    }
    getAccessToken() {
        return internal_1.AccessToken.getAccessToken(this.apiServer, this.deviceId, this.provisioningCode);
    }
    //@ts-ignore
    postReport(reportObj, tokenObj) {
        return new Promise((resolve, reject) => {
            try {
                // DJB - 2/24/2023
                // We are removing XMLHttpRequest.js from the library because we were only keeping it
                // around to be backwards compatible with the original Chromebook implementation in the common
                // client code. Now that fetch() is being used everywhere in lieu of XHR, this is the only
                // remaining place where XHR is used. We're not using metrics at this time so be
                // advised that this should be switched over to use fetch().
                let xhr = new XMLHttpRequest();
                xhr.onreadystatechange = () => {
                    if (xhr.readyState === XMLHttpRequest.DONE) {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            this.logger.logMessage('MetricReporter.postReport(): Sent metric report: ' + JSON.stringify(reportObj));
                            resolve();
                        }
                        else {
                            reject(xhr.status);
                        }
                    }
                };
                xhr.open('POST', this.reportingEndpoint, true);
                xhr.setRequestHeader("Content-type", "application/json");
                xhr.setRequestHeader("Authorization", tokenObj.access_token);
                xhr.send(JSON.stringify(reportObj));
            }
            catch (err) {
                reject(err);
            }
        });
    }
}
exports.MetricReporter = MetricReporter;
//# sourceMappingURL=metrics.js.map