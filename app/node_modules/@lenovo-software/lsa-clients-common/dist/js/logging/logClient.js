"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogClientEx = void 0;
const logger_1 = require("./logger");
function LogClient() {
    /*
    Retrieves buffer from logger by calling pullBuffer() and passing in the current log marker.
    */
    this.getLog = function (ringBuffer) {
        if (!ringBuffer) {
            ringBuffer = 'default-rb';
        }
        // logger.pullBuffer is guaranteed to always return a number greater than or equal to what is passed into it.
        this.pendingLog = logger_1.logger.pullBuffer(this.currentLogMarker, ringBuffer);
        if (this.pendingLog.logMarker >
            this.currentLogMarker + this.pendingLog.logEntries.length) {
            // The log has wrapped so currentLogMarker must be adjusted accordingly
            this.currentLogMarker =
                this.pendingLog.logMarker - this.pendingLog.logEntries.length;
        }
        this.startingMarker = this.currentLogMarker;
        return this.pendingLog;
    };
    /*
    Returns whether or not all elements retrieved from the last getLog() call have been successfully processed.
    */
    this.isCommitComplete = function () {
        if (this.currentLogMarker > this.pendingLog.logMarker)
            throw new Error('currentLogMarker > pendingLog.logMarker');
        return this.pendingLog.logMarker === this.currentLogMarker;
    };
    /*
    Indicates that elementsCommitted have been successfully processed. For example, if 5 log elements
    were pulled from getLog(), and 2 were successfully processed, this would be called with 2.
    */
    this.commitLogTransmission = function (elementsCommitted) {
        this.currentLogMarker += elementsCommitted;
    };
    /*
    Returns the ordinal for the next log entry which must be processed.
    */
    this.getLogMarker = function () {
        return this.currentLogMarker - this.startingMarker;
    };
    this.reset = function () {
        this.startingMarker = 0;
        this.lastCommitted = 0;
        this.currentLogMarker = 0;
        this.pendingLog = {
            logMarker: 0,
            logEntries: []
        };
    };
    this.reset();
}
class LogClientEx {
    constructor(ringBuffers) {
        this.ringBuffers = ringBuffers;
    }
    getLogs() {
        let allBuffers = {
            logEntries: new Array()
        };
        for (let i = 0; i < this.ringBuffers.length; i++) {
            try {
                const theLog = new LogClient().getLog(this.ringBuffers[i]);
                if (theLog.logEntries) {
                    for (let j = 0; j < theLog.logEntries.length; j++) {
                        allBuffers.logEntries.push(theLog.logEntries[j]);
                    }
                }
            }
            catch (e) {
                let immediateLogEntry = logger_1.logger.getLogEntryObject(logger_1.logger.timeStamp(), (e === null || e === void 0 ? void 0 : e.message) || 'Error in LogClientEx.getLogs()', 'LOGEXPORT', 'ERROR');
                allBuffers.logEntries.push(immediateLogEntry);
            }
        }
        allBuffers.logEntries.sort((a, b) => {
            let ret = 0;
            try {
                const aDate = Date.parse(a.date);
                const bDate = Date.parse(b.date);
                if (aDate < bDate) {
                    ret = -1;
                }
                if (aDate > bDate) {
                    ret = 1;
                }
            }
            catch (e) { }
            return ret;
        });
        return allBuffers;
    }
}
exports.LogClientEx = LogClientEx;
//# sourceMappingURL=logClient.js.map