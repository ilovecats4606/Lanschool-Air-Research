"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = void 0;
const pubsub_js_1 = require("pubsub-js");
const defs_1 = require("../defs");
const internal_1 = require("../../internal");
//import { console } from '../interop/consoleLogInterop';
console.realDebug = function (msg) {
  _debug.apply(console, arguments);
};
console.realLog = function (msg) {
  console.log.apply(console, arguments);
};
console.realWarning = function (msg) {
  _warning.apply(console, arguments);
};
console.realError = function (msg) {
  _error.apply(console, arguments);
};
/* eslint-disable no-inner-declarations */
/* eslint-disable no-console */
/* eslint-disable no-undef */
function RingBuf(size) {
  this.a = new Array(size);
  this.l = 0;
  this.s = size;
}
RingBuf.InvalidIndex = {};
RingBuf.prototype.get = function (i) {
  if (i < 0) throw RingBuf.InvalidIndex;
  return this.a[i % this.a.length];
};
RingBuf.prototype.set = function (i, v) {
  if (i < 0 || i < this.l - this.a.length) {
    throw RingBuf.InvalidIndex;
  }
  this.a[i % this.a.length] = v;
  if (i == this.l) this.l++;
};
RingBuf.prototype.push = function (v) {
  if (Array.isArray(v)) {
    let cl = this.l;
    for (let i = 0; i < v.length; i++) {
      this.set(i + cl, v[i]);
    }
  } else this.set(this.l, v);
};
RingBuf.prototype.slice = function (s) {
  return this.sliceToMax(s, Number.MAX_VALUE);
};
RingBuf.prototype.sliceToMax = function (s, maxReturn) {
  let ret = [];
  let ts = 0; // Wrap-around OK but don't return more elements than the size of the array
  let max = Math.min(this.a.length, maxReturn);
  if (isNaN(max)) {
    throw new Error("Parameter is not a number");
  }
  for (let i = s; i < this.l && ts < max; i++) {
    ret.push(this.get(i));
    ts++;
  }
  return ret;
};
const defaultRB = "default-rb";
RingBuf.prototype.clearBuffer = function () {
  delete this.a;
  this.a = new Array(this.s);
  this.l = 0;
};
var logger = new (function () {
  var self = this;
  this.ringBuf = { "default-rb": new RingBuf(defs_1.LogBufferSize) };
  this.logToConsole = true;
  this.masterLogger = false;
  this.deviceID = "";
  this.loggerID = "";
  pubsub_js_1.PubSub.subscribe("onCoreDumpLogs", (msg, data) => {
    if (data && data.ringBufferName) {
      // Push this entire ring buffer onto the 'default-rb' ring buffer.
      // It might obliterate it, but maybe sometime we make ring buffers that aren't the default smaller?
      const buffer = this.pullBuffer(0, data.ringBufferName);
      if (!buffer || !buffer.logEntries || !Array.isArray(buffer.logEntries)) {
        return;
      }
      buffer.logEntries.forEach((element) => {
        var _a, _b, _c, _d;
        if (element) {
          this.ringBuf[defaultRB].push({
            deviceId:
              (_a = element.deviceId) !== null && _a !== void 0 ? _a : "",
            severity:
              (_b = element.severity) !== null && _b !== void 0 ? _b : "",
            date: (_c = element.date) !== null && _c !== void 0 ? _c : "",
            entry:
              (_d = "*CORE DUMP* " + element.entry) !== null && _d !== void 0
                ? _d
                : "",
          });
        }
      });
      this.clearBuffer(data.ringBufferName);
    }
  });
  // It's super important that listeners on other pages do not log unknown messages as this will create a feedback loop.
  internal_1.chrome.runtime.onMessage.addListener(function (request) {
    if (request.message === "LogMsg" && self.masterLogger) {
      if (request.hasOwnProperty("severity")) {
        self.logMessageWithTimestamp(
          request.timestamp || self.timeStamp() + "??",
          request.msg,
          request.severity,
          request.loggerID || "unknown"
        );
      } else {
        self.logMessage(request.msg);
      }
    }
  });
  this.setDeviceID = function (deviceID, ringBuffer) {
    // Change everything in the current buffer to have this deviceID
    const rb =
      ringBuffer !== null && ringBuffer !== void 0 ? ringBuffer : defaultRB;
    if (!this.ringBuf[rb]) {
      throw new Error(
        "logger.setDeviceID(): Ring buffer '" + rb + "' not found."
      );
    }
    let changeThisMany = Math.min(this.ringBuf[rb].l, this.ringBuf[rb].s);
    for (let i = 0; i < changeThisMany; i++) {
      let o = this.ringBuf[rb].get(i);
      o.deviceId = deviceID;
    }
    this.deviceID = deviceID;
  };
  this.clearBuffer = function (ringBuffer) {
    const rb =
      ringBuffer !== null && ringBuffer !== void 0 ? ringBuffer : defaultRB;
    if (!this.ringBuf[rb]) {
      throw new Error(
        "logger.clearBuffer(): Ring buffer '" + rb + "' not found."
      );
    }
    this.ringBuf[rb].clearBuffer();
  };
  this.pullBuffer = function (marker, ringBuffer) {
    const rb =
      ringBuffer !== null && ringBuffer !== void 0 ? ringBuffer : defaultRB;
    if (!this.ringBuf[rb]) {
      throw new Error(
        "logger.pullBuffer(): Ring buffer '" + rb + "' not found."
      );
    }
    return {
      logMarker: this.ringBuf[rb].l,
      logEntries: this.ringBuf[rb].slice(marker),
    };
  };
  this.shouldAddToRingBuf = function (msg, severity) {
    if (msg && msg.includes("!$$RB")) {
      // Example: !$$RB::SIO::my log message
      const rbTokens = msg.split("::");
      if (rbTokens && rbTokens.length > 1) {
        return {
          ringBuffer: rbTokens[1],
          msg: rbTokens.length > 2 ? rbTokens[2] : msg,
        };
      }
    }
    return {
      ringBuffer: defaultRB,
      msg: msg,
    };
  };
  this.getLogEntryObject = function (ts, msg, loggerID, severity) {
    return {
      deviceId: this.deviceID,
      severity: severity,
      date: ts,
      entry:
        ((loggerID && loggerID.length) > 0 ? "[" + loggerID + "] " : "") + msg,
    };
  };
  this.doLogEntry = function (ts, msg, loggerID, severity) {
    const logEntry =
      ((loggerID && loggerID.length) > 0
        ? "[" + loggerID + "] " + ts + ": "
        : "") + msg;
    if (typeof msg !== "string" && !(msg instanceof String)) {
      msg = JSON.stringify(msg);
    }
    const ringBufInstance = this.shouldAddToRingBuf(msg, severity);
    if (
      ringBufInstance &&
      ringBufInstance.ringBuffer &&
      ringBufInstance.msg &&
      ringBufInstance.msg.length > 0
    ) {
      if (!this.ringBuf[ringBufInstance.ringBuffer]) {
        this.ringBuf[ringBufInstance.ringBuffer] = new RingBuf(
          defs_1.LogBufferSize
        );
      }
      this.ringBuf[ringBufInstance.ringBuffer].push(
        this.getLogEntryObject(ts, ringBufInstance.msg, loggerID, severity)
      );
    }
    return logEntry;
  };
  this.logMessageWithTimestamp = function (
    ts,
    msg,
    severity,
    loggerID,
    consoleCallback
  ) {
    if (this.masterLogger) {
      let logEntry = this.doLogEntry(ts, msg, loggerID, severity);
      if (this.logToConsole) {
        if (!consoleCallback) {
          switch (severity) {
            case "INFO":
              {
                consoleCallback = console.realLog;
              }
              break;
            case "WARN":
              {
                consoleCallback = console.realWarning;
              }
              break;
            case "ERROR":
              {
                consoleCallback = console.realError;
              }
              break;
            case "DEBUG":
              {
                consoleCallback = console.realDebug;
              }
              break;
            default: {
              consoleCallback = console.realLog;
            }
          }
        }
        if (consoleCallback) consoleCallback(logEntry);
        else {
          console.realError("NO CONSOLE_CALLBACK: " + logEntry);
        }
      }
    } else {
      internal_1.chrome.runtime.sendMessage({
        loggerID: loggerID,
        timestamp: ts,
        message: "LogMsg",
        severity: severity,
        msg: msg,
      });
    }
  };
  this.logError = function (msg) {
    let ts = this.timeStamp();
    this.logMessageWithTimestamp(
      ts,
      msg,
      "ERROR",
      this.loggerID,
      console.realError
    );
  }.bind(this);
  this.logWarning = function (msg) {
    let ts = this.timeStamp();
    this.logMessageWithTimestamp(
      ts,
      msg,
      "WARN",
      this.loggerID,
      console.realWarn
    );
  }.bind(this);
  this.logMessage = function (msg) {
    let ts = this.timeStamp();
    this.logMessageWithTimestamp(
      ts,
      msg,
      "INFO",
      this.loggerID,
      console.realLog
    );
  }.bind(this);
  this.logDebug = function (msg) {
    let ts = this.timeStamp();
    this.logMessageWithTimestamp(
      ts,
      msg,
      "DEBUG",
      this.loggerID,
      console.realDebug
    );
  }.bind(this);
  this.timeStamp = function () {
    return this.timeStampMS(true);
  };
  this.timeStampMS = function (doMS) {
    // Create a date object with the current time
    var now = new Date();
    var date = [now.getMonth() + 1, now.getDate(), now.getFullYear()];
    var time = [now.getHours(), now.getMinutes(), now.getSeconds()];
    var time_ms = now.getMilliseconds();
    // If seconds and minutes are less than 10, add a zero
    for (var i = 1; i < 3; i++) {
      if (time[i] < 10) {
        time[i] = "0" + time[i];
      }
    }
    if (time_ms < 10) {
      time_ms = "00" + time_ms;
    } else if (time_ms < 100) {
      time_ms = "0" + time_ms;
    }
    // Return the formatted string
    var dateTime = date.join("/") + " " + time.join(":");
    if (doMS) dateTime += "." + time_ms;
    return dateTime;
  };
  function setPropByString(obj, ps, setVal) {
    if (!ps) return;
    var p,
      pa = ps.split(".");
    for (var i = 0, iLen = pa.length - 1; i < iLen; i++) {
      p = pa[i];
      var c = obj[p];
      if (c !== undefined) {
        obj = c;
      } else {
        break;
      }
    }
    obj[pa[i]] = setVal;
  }
  this.stringifyWithout = function (data, propertiesToIgnore) {
    // Make a copy of the object to use locally
    var temp = JSON.parse(JSON.stringify(data));
    if (
      propertiesToIgnore &&
      typeof propertiesToIgnore === "object" &&
      propertiesToIgnore instanceof Array
    ) {
      for (var i = 0; i < propertiesToIgnore.length; i++) {
        setPropByString(temp, propertiesToIgnore[i], "...");
      }
    }
    return JSON.stringify(temp);
  };
})();
exports.logger = logger;
// Override XHR for logging
if (typeof XMLHttpRequest !== "undefined") {
  let open = XMLHttpRequest.prototype.open,
    send = XMLHttpRequest.prototype.send;
  XMLHttpRequest.prototype.doLogging = true;
  XMLHttpRequest.prototype._url = "";
  function openWithLogging(method, url) {
    if (this.doLogging) {
      this._url = url;
      console.log("{XHR} Opening URL [" + url + "]");
    }
    return open.apply(this, arguments);
  }
  function sendWithLogging() {
    if (this.onreadystatechange) {
      this._onreadystatechange = this.onreadystatechange;
    }
    if (this.onerror) {
      this._onerror = this.onerror;
    }
    if (this.onload) {
      this._onload = this.onload;
    }
    if (this.onloadstart) {
      this._onloadstart = this.onloadstart;
    }
    if (this.onloadend) {
      this._onloadend = this.onloadend;
    }
    if (this.onabort) {
      this._onabort = this.onabort;
    }
    if (this.ontimeout) {
      this._ontimeout = this.ontimeout;
    }
    if (this.doLogging) {
      console.log("{XHR} Request sent to [" + this._url + "]");
    }
    this.onreadystatechange = onReadyStateChangeWithLogging;
    this.onerror = onErrorWithLogging;
    this.onload = onLoadWithLogging;
    this.onloadstart = onLoadStartWithLogging;
    this.onloadend = onLoadEndWithLogging;
    this.onabort = onAbortWithLogging;
    this.ontimeout = onTimeoutWithLogging;
    return send.apply(this, arguments);
  }
  function onErrorWithLogging() {
    if (this.doLogging) {
      console.log("{XHR} Got error for [" + this._url + "]");
    }
    if (this._onerror) {
      return this._onerror.apply(this, arguments);
    }
  }
  function onLoadWithLogging() {
    if (this.doLogging) {
      console.log("{XHR} in onload for [" + this._url + "]");
    }
    if (this._onload) {
      return this._onload.apply(this, arguments);
    }
  }
  function onLoadStartWithLogging() {
    if (this.doLogging) {
      console.log("{XHR} in onloadstart for [" + this._url + "]");
    }
    if (this._onloadstart) {
      return this._onloadstart.apply(this, arguments);
    }
  }
  function onLoadEndWithLogging() {
    if (this.doLogging) {
      console.log("{XHR} in onloadend for [" + this._url + "]");
    }
    if (this._onloadend) {
      return this._onloadend.apply(this, arguments);
    }
  }
  function onAbortWithLogging() {
    if (this.doLogging) {
      console.log("{XHR} in onabort for [" + this._url + "]");
    }
    if (this._onabort) {
      return this._onabort.apply(this, arguments);
    }
  }
  function onTimeoutWithLogging() {
    if (this.doLogging) {
      console.log("{XHR} in ontimeout for [" + this._url + "]");
    }
    if (this._ontimeout) {
      return this._ontimeout.apply(this, arguments);
    }
  }
  function translateState(state) {
    let ret = "unknown (" + state + ")";
    switch (state) {
      case 4:
        ret = "DONE";
        break;
      case 2:
        ret = "HEADERS_RECEIVED";
        break;
      case 3:
        ret = "LOADING";
        break;
      case 1:
        ret = "OPENED";
        break;
      case 0:
        ret = "UNSENT";
        break;
    }
    return ret;
  }
  function onReadyStateChangeWithLogging() {
    if (this.doLogging) {
      console.log(
        "{XHR} [" +
          this._url +
          "] Ready state is now [" +
          translateState(this.readyState) +
          "], status: " +
          this.status
      );
    }
    if (this._onreadystatechange) {
      return this._onreadystatechange.apply(this, arguments);
    }
  }
  XMLHttpRequest.prototype.open = openWithLogging;
  XMLHttpRequest.prototype.send = sendWithLogging;
}
if (typeof exports !== "undefined") {
  exports.RingBuf = RingBuf;
  exports.Logger = logger;
} else {
  // Override console log to call our logger
  // This only happens in a non-Node environment so as to allow unit tests to display results
  var _debug = console.debug;
  var _log = console.log;
  var _error = console.error;
  var _warning = console.warn;
  console.debug = function (msg) {
    logger.logDebug(msg);
  };
  // eslint-disable-next-line no-unused-vars
  console.realDebug = function (msg) {
    _debug.apply(console, arguments);
  };
  console.log = function (msg) {
    logger.logMessage(msg);
  };
  // eslint-disable-next-line no-unused-vars
  console.realLog = function (msg) {
    _log.apply(console, arguments);
  };
  console.warning = function (msg) {
    logger.logWarning(msg);
  };
  // eslint-disable-next-line no-unused-vars
  console.realWarning = function (msg) {
    _warning.apply(console, arguments);
  };
  console.error = function (msg) {
    logger.logError(msg);
  };
  // eslint-disable-next-line no-unused-vars
  console.realError = function (msg) {
    _error.apply(console, arguments);
  };
}
//# sourceMappingURL=logger.js.map
