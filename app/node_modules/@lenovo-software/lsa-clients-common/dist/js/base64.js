"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base64ToArrayBufferEx = exports.ArrayBufferToBase64ExPadding = exports.SoftBase64Exchange = exports.ArrayBufferToBase64Ex = void 0;
/* eslint-disable no-unused-vars */
/**
 * Base54 encoding / decoding of ArrayBuffer
 */
var g_encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
function SoftBase64Exchange(origBase64Encoding) {
    var ret = origBase64Encoding.replace(/\//g, "_");
    ret = ret.replace(/\+/g, "-");
    return ret;
}
exports.SoftBase64Exchange = SoftBase64Exchange;
/** faster "non-native" way
 *
 */
function ArrayBufferToBase64Ex(arrayBuffer) {
    return ArrayBufferToBase64ExPadding(arrayBuffer, true);
}
exports.ArrayBufferToBase64Ex = ArrayBufferToBase64Ex;
function ArrayBufferToBase64ExPadding(arrayBuffer, doPadding) {
    var base64 = '';
    var bytes = new Uint8Array(arrayBuffer);
    var byteLength = bytes.byteLength;
    var byteRemainder = byteLength % 3;
    var mainLength = byteLength - byteRemainder;
    var a, b, c, d;
    var chunk;
    //  console.log( "Base64 encoding " + arrayBuffer.byteLength + " bytes of data" );
    //  console.log( "new buffer " + byteLength + " bytes of data, " + byteRemainder + " remainder, " + mainLength + " main length" );
    // Main loop deals with bytes in chunks of 3
    for (var i = 0; i < mainLength; i = i + 3) {
        // Combine the three bytes into a single integer
        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        // Use bitmasks to extract 6-bit segments from the triplet
        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
        d = chunk & 63; // 63       = 2^6 - 1
        // Convert the raw binary segments to the appropriate ASCII encoding
        base64 += g_encodings[a] + g_encodings[b] + g_encodings[c] + g_encodings[d];
    }
    // Deal with the remaining bytes and padding
    if (byteRemainder == 1) {
        chunk = bytes[mainLength];
        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
        // Set the 4 least significant bits to zero
        b = (chunk & 3) << 4; // 3   = 2^2 - 1
        if (doPadding)
            base64 += g_encodings[a] + g_encodings[b] + '==';
        else
            base64 += g_encodings[a] + g_encodings[b];
    }
    else if (byteRemainder == 2) {
        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
        // Set the 2 least significant bits to zero
        c = (chunk & 15) << 2; // 15    = 2^4 - 1
        if (doPadding)
            base64 += g_encodings[a] + g_encodings[b] + g_encodings[c] + '=';
        else
            base64 += g_encodings[a] + g_encodings[b] + g_encodings[c];
    }
    //console.log( "Encoded data is " + base64.length + " bytes" );
    return base64;
}
exports.ArrayBufferToBase64ExPadding = ArrayBufferToBase64ExPadding;
/**
 *convert Base64 back to ArrayBuffer
 *
 * returns ArrayBuffer
 **/
function Base64ToArrayBufferEx(input) {
    var bytes = (input.length / 4) * 3;
    var uarray = null;
    //	var arrayBuffer
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    var j = 0;
    //get last chars to see if are valid
    var lkey1 = g_encodings.indexOf(input.charAt(input.length - 1));
    var lkey2 = g_encodings.indexOf(input.charAt(input.length - 2));
    //	console.log( "Decoding data: [" + input + "]" );
    //	console.log( "Expected result, " + bytes + " bytes " );
    //	console.log( "Trailing: [" + input.charAt(input.length-2) + "("+ lkey2+")," + input.charAt(input.length-1) + "("+ lkey1+")]" );
    if (lkey1 == 64)
        bytes--; //padding chars, so skip
    if (lkey2 == 64)
        bytes--; //padding chars, so skip
    let arrayBuffer = new ArrayBuffer(bytes);
    //	console.log( "Updated result, " + bytes + " bytes " );
    uarray = new Uint8Array(arrayBuffer, 0);
    //uarray = new Uint8Array(bytes);
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    for (i = 0; i < bytes; i += 3) {
        //get the 3 octects in 4 ascii chars
        enc1 = g_encodings.indexOf(input.charAt(j++));
        enc2 = g_encodings.indexOf(input.charAt(j++));
        enc3 = g_encodings.indexOf(input.charAt(j++));
        enc4 = g_encodings.indexOf(input.charAt(j++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        uarray[i] = chr1;
        if (enc3 != 64)
            uarray[i + 1] = chr2;
        if (enc4 != 64)
            uarray[i + 2] = chr3;
    }
    var len = uarray.byteLength;
    var output = '';
    /* TEST **
    var view = new Uint8Array( arrayBuffer, 0 );
    for (var i = 0; i < len; i++)
    {
        output += String.fromCharCode( view[ i ] );
        console.log( "R: " + uarray[ i ] );
    }
    console.log( "DECODED DATA: [" + output + "] " + output.length + " bytes");
    
    ** END TEST */
    //	console.log( "Returning decoded data: " + uarray.byteLength + " bytes" );
    return arrayBuffer;
}
exports.Base64ToArrayBufferEx = Base64ToArrayBufferEx;
if (typeof exports !== 'undefined') {
    exports.SoftBase64Exchange = SoftBase64Exchange;
    exports.ArrayBufferToBase64ExPadding = ArrayBufferToBase64ExPadding;
    exports.ArrayBufferToBase64Ex = ArrayBufferToBase64Ex;
    exports.Base64ToArrayBufferEx = Base64ToArrayBufferEx;
}
//# sourceMappingURL=base64.js.map