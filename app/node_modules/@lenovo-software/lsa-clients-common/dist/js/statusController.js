"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusController = void 0;
const pubsub_js_1 = require("pubsub-js");
const defs_1 = require("./defs");
const internal_1 = require("../internal");
/* eslint-disable no-undef */
function StatusModel() {
    this.provisioned = false;
    this.validToken = false;
    this.connected = defs_1.ConnectionStateEnum.Disconnected;
    this.joinedClass = "";
    this.payloadVerificationFailure = false;
    this.colorLED = defs_1.LEDColors.Red;
    this.lastError = "";
}
var StatusController = new function () {
    var self = this;
    this.model = new StatusModel();
    pubsub_js_1.PubSub.subscribe('onProvisionStatus', function (msg, data) {
        if (data.hasOwnProperty('provisioned')) {
            self.model.provisioned = data.provisioned;
            if (data.hasOwnProperty("error")) {
                if (data.error.hasOwnProperty("offline") &&
                    data.error.offline) {
                    self.model.lastError = internal_1.chrome.i18n.getMessage("client_offline") || "The device may be offline.";
                }
                else if (data.error.hasOwnProperty("error")) {
                    self.model.lastError = data.error.error;
                }
            }
            else {
                self.model.lastError = "";
            }
            self.updateStatus();
        }
    });
    pubsub_js_1.PubSub.subscribe('onTokenStatus', function (msg, data) {
        if (data.hasOwnProperty('validToken')) {
            self.model.validToken = data.validToken;
            if (data.hasOwnProperty('error')) {
                self.model.lastError = data.error;
            }
            self.updateStatus();
        }
    });
    pubsub_js_1.PubSub.subscribe('onConnectionStateChange', function (msg, data) {
        if (!data) {
            return;
        }
        if (data.hasOwnProperty('connected')) {
            self.model.connected = data.connected;
        }
        if (data.hasOwnProperty('lastError')) {
            switch (data.lastError) {
                case 'TransportError': {
                    self.model.lastError = internal_1.chrome.i18n.getMessage('client_offline') || "The device may be offline.";
                    break;
                }
                case 'timeout': {
                    self.model.lastError = internal_1.chrome.i18n.getMessage('server_timeout') || "Timed out trying to reach server.";
                    break;
                }
                default: {
                    self.model.lastError = '';
                    break;
                }
            }
        }
        self.updateStatus();
    });
    pubsub_js_1.PubSub.subscribe('onIPAddressDenial', () => {
        self.model.connected = defs_1.ConnectionStateEnum.Disconnected;
        self.model.lastError = internal_1.chrome.i18n.getMessage("ip_address_restriction") || "IP address restriction";
        self.updateStatus();
    });
    pubsub_js_1.PubSub.subscribe('onPayloadVerificationFailure', () => {
        self.model.payloadVerificationFailure = true;
        self.updateStatus();
    });
    pubsub_js_1.PubSub.subscribe('onJoinClass', function (msg, data) {
        if (data.hasOwnProperty("className") &&
            data.className.length > 0) {
            self.model.joinedClass = data.className;
        }
        else if (data.hasOwnProperty("classID") &&
            data.classID.length > 0) {
            self.model.joinedClass = data.classID;
        }
        else
            self.model.joinedClass = "{unknown}";
        self.updateStatus();
    });
    pubsub_js_1.PubSub.subscribe('onLeaveClass', () => {
        self.model.joinedClass = "";
        self.updateStatus();
    });
    this.buildProvisioningStatusObject = function () {
        let iconColor = defs_1.LEDColorsString.Red;
        let localizedMessage = internal_1.chrome.i18n.getMessage('device_not_provisioned');
        if (this.model.provisioned === true) {
            iconColor = defs_1.LEDColorsString.Green;
            localizedMessage = internal_1.chrome.i18n.getMessage('device_provisioned');
        }
        return {
            detailType: "Provisioning",
            iconColor: iconColor,
            localizedMessage: localizedMessage
        };
    };
    this.buildTokenValidityStatusObject = function () {
        let iconColor = defs_1.LEDColorsString.Red;
        let localizedMessage = internal_1.chrome.i18n.getMessage('no_valid_token');
        if (this.model.validToken === true) {
            iconColor = defs_1.LEDColorsString.Green;
            localizedMessage = internal_1.chrome.i18n.getMessage('valid_token');
        }
        return {
            detailType: "TokenValidity",
            iconColor: iconColor,
            localizedMessage: localizedMessage
        };
    };
    this.buildConnectivityStatusObject = function () {
        let iconColor = defs_1.LEDColorsString.Red;
        let localizedMessage = internal_1.chrome.i18n.getMessage('not_connected_to_server');
        if (this.model.connected === defs_1.ConnectionStateEnum.Connected) {
            iconColor = defs_1.LEDColorsString.Green;
            localizedMessage = internal_1.chrome.i18n.getMessage('connected_to_server');
        }
        return {
            detailType: "Connectivity",
            iconColor: iconColor,
            localizedMessage: localizedMessage
        };
    };
    this.modelToConnectivityStatusMessageArray = function () {
        return [
            this.buildProvisioningStatusObject(),
            this.buildTokenValidityStatusObject(),
            this.buildConnectivityStatusObject()
        ];
    };
    // NOTE WHEN PORTING TO TYPESCRIPT: The models being built here are the same as the StudentStatusDetailMessage.
    // Use that data structure and remove the interop code to handle the "ToWebView" chrome message
    // as well as the code in StudentStatusModel.fromAny(). Build an instance of StudentStatusModel populated with
    // this information, then call LSAClient.getStatusLightImpl()?.statusNotification() with the StudentStatusModel.
    this.updateStatus = function () {
        if (this.model.connected === defs_1.ConnectionStateEnum.Connected)
            this.model.colorLED = defs_1.LEDColorsString.Green;
        else if (this.model.provisioned && !this.validToken)
            this.model.colorLED = defs_1.LEDColorsString.Amber;
        else if (!this.provisioned)
            this.model.colorLED = defs_1.LEDColorsString.Red;
        const param = {
            message: "UI_SetConnectivityStatus",
            status: {
                ledColor: this.model.colorLED,
                messages: this.modelToConnectivityStatusMessageArray(),
                lastError: this.model.lastError
            }
        };
        internal_1.chrome.runtime.sendMessage({
            message: "ToWebView",
            params: param,
            openWindow: false
        });
    };
};
exports.StatusController = StatusController;
//# sourceMappingURL=statusController.js.map