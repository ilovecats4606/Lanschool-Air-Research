"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketIOMsg = exports.ConnectionRetryManager = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const socket_io_client_1 = __importDefault(require("socket.io-client"));
const json_stringify_safe_1 = __importDefault(require("json-stringify-safe"));
const defs_1 = require("./js/defs");
const internal_1 = require("./internal");
const logger = new internal_1.LoggerInterop();
const preferences = new internal_1.StorageInterop();
const heartbeat = new internal_1.Heartbeat();
const TelemetryMessageType = 'currentTelemetry';
const CurrentScreenMessageType = 'currentScreen';
const IntellitaskMessageType = 'intelliTaskMessage';
const setHeartbeatTimer = (val) => {
    heartbeat.setHeartbeatTimer(val);
};
const _stringify = JSON.stringify;
JSON.stringify = function (obj, replacer, space) {
    return _stringify.apply(JSON, [
        obj,
        json_stringify_safe_1.default.getSerialize(replacer, undefined),
        space
    ]);
};
const callStartConnection = (socketIOMsg, connectionParams) => {
    // For setTimeout... There's probably a better way to bind this object but this works.
    socketIOMsg.logDebug('callStartConnection(+)');
    socketIOMsg.connectionRetryManager.reset();
    socketIOMsg.startConnection(connectionParams);
};
class ConnectionRetryManager {
    constructor() {
        this.expireTime = -1;
        this.timeoutId = -1; // TS referring NodeJS version of setTimeout
    }
    reset() {
        this.myClearTimeout();
        this.timeoutId = -1;
        this.expireTime = -1;
    }
    myClearTimeout() {
        if (this.timeoutId >= 0) {
            clearTimeout(this.timeoutId);
            this.timeoutId = -1;
        }
    }
    doConnectionRetry(timeout, socketIOMsg, connectionParams) {
        if (!socketIOMsg) {
            logger.logError('ConnectionRetryManager.doConnectionRetry(): Missing SocketIOMsg instance.');
        }
        socketIOMsg.logDebug('ConnectionRetryManager.doConnectionRetry(+)');
        if (!socketIOMsg.shouldRetrySocketConnection()) {
            socketIOMsg.logMessage('ConnectionRetryManager.doConnectionRetry(): Not retrying.');
            return;
        }
        const currentTime = Date.now();
        if (this.timeoutId < 0) {
            // No retries pending
            this.expireTime = currentTime + timeout;
        }
        else {
            // A timer is already running. Will it expire sooner than what is already going?
            if (this.expireTime > currentTime + timeout) {
                this.myClearTimeout();
                this.expireTime = currentTime + timeout;
            }
            else {
                // Returning because new request is longer or the same as the current request.
                socketIOMsg.logMessage('ConnectionRetryManager.doConnectionRetry(): ' +
                    'Not calling startConnection because new request is longer than the current request: expireTime = ' +
                    this.expireTime +
                    ', currentTime = ' +
                    currentTime +
                    ', timeout = ' +
                    timeout);
                return;
            }
        }
        socketIOMsg.logDebug('ConnectionRetryManager.doConnectionRetry(): Will call callStartConnection() in ' +
            timeout);
        this.timeoutId = setTimeout(callStartConnection, timeout, socketIOMsg, connectionParams);
    }
}
exports.ConnectionRetryManager = ConnectionRetryManager;
class SocketIOMsg {
    constructor(sioParams) {
        var _a, _b, _c, _d;
        this.connectionRetryManager = new ConnectionRetryManager();
        this.unsignedOutgoingMessageTypes = [
            'join',
            'leave',
            'lookup',
            'clientPong',
            'sendBrowserEvent'
        ];
        this.connected = defs_1.ConnectionStateEnum.Disconnected;
        this.lastError = '';
        this.server = '';
        this.machineCode = '';
        this.deviceName = '';
        this.provisioningErrorAttempts = 0;
        this.nextConnectTime = -1;
        this.idForController = -1;
        this.xmitQueue = [];
        this.apiServer = '';
        this.accessToken = '';
        this.orgId = '';
        this.orgName = '';
        this.studentDbId = '';
        logger.logMessage('SocketIOMsg(+)');
        this.LStudent = sioParams.LStudent;
        this.teacherMessageVerifier =
            (_a = sioParams.messageVerifier) !== null && _a !== void 0 ? _a : new internal_1.MessageVerification();
        this.metricAccumulator = (_b = sioParams.metricAccumulator) !== null && _b !== void 0 ? _b : undefined;
        this.controller = (_c = sioParams.controller) !== null && _c !== void 0 ? _c : undefined;
        this.idForController = (_d = sioParams.idForController) !== null && _d !== void 0 ? _d : -1;
    }
    shouldRetrySocketConnection() {
        return this.controller.shouldRetrySocketConnection(this.idForController);
    }
    getIdForController() {
        return this.idForController;
    }
    startConnection(data) {
        var _a, _b;
        if (this.connected !== defs_1.ConnectionStateEnum.Disconnected) {
            this.logMessage('startConnection(): Exiting. Connection state is ' +
                this.connected);
            return;
        }
        if (!this.controller) {
            this.logError('startConnection(): No socket controller specified.');
            return;
        }
        if (this.nextConnectTime > 0) {
            var currentTime = Date.now();
            if (currentTime < this.nextConnectTime) {
                // Still not time yet!
                this.connectionRetryManager.doConnectionRetry(10000, this, data);
                return;
            }
        }
        this.logMessage('startConnection(): Starting connection.');
        data.machineCode =
            (_a = data.humanCode) !== null && _a !== void 0 ? _a : ((_b = this.LStudent.policy.provisioning_code) !== null && _b !== void 0 ? _b : '');
        //@ts-ignore
        this.machineCode = data.machineCode;
        this.deviceName = data.deviceName;
        if (!data.apiServer.endsWith('/'))
            data.apiServer += '/';
        this.LStudent.apiServer = data.apiServer;
        this.apiServer = this.LStudent.apiServer;
        //@ts-ignore
        internal_1.AccessToken.getAccessToken(data.apiServer, data.deviceName, data.machineCode)
            .then((connectData) => {
            const provisioningData = preferences.getSetting('provisioningData');
            this.controller
                .isIPAllowed(this.idForController, provisioningData === null || provisioningData === void 0 ? void 0 : provisioningData.orgID)
                .then(() => {
                this.setConnectedState(defs_1.ConnectionStateEnum.Trying);
                this.controller
                    .retrieveSocketServer(this.idForController, connectData.access_token)
                    .then((socketServerData) => {
                    this.logMessage('startConnection(): SocketEndpoint call successful. Socket server is: ' +
                        socketServerData.socketServerEndpoint);
                    this.server =
                        socketServerData.socketServerEndpoint;
                    this.connect({
                        accessToken: connectData.access_token,
                        device_db_id: provisioningData.id,
                        org_id: provisioningData.orgID,
                        vanity_name: data.vanity_name,
                        server: socketServerData.socketServerEndpoint,
                        apiServer: this.LStudent.apiServer
                    });
                })
                    .catch((errObj) => {
                    this.setConnectedState(defs_1.ConnectionStateEnum.Disconnected);
                    if (errObj !== null) {
                        if (errObj.error === 'Unauthorized') {
                            this.logMessage('startConnection(): SocketEndpoint call failed: Unauthorized');
                            this.onTokenError(401);
                        }
                        else {
                            this.logMessage('startConnection(): SocketEndpoint call failed: ' +
                                JSON.stringify(errObj));
                            this.setConnectionParamsAndRetry();
                        }
                    }
                    else {
                        this.logMessage('startConnection(): SocketEndpoint call failed. Error object null.');
                        this.setConnectionParamsAndRetry();
                    }
                });
            })
                .catch(() => {
                this.logWarning('startConnection(): Not allowed to access LanSchool Air from this address. Retrying later...');
                pubsub_js_1.default.publish('onIPAddressDenial');
                this.connectionRetryManager.doConnectionRetry(60000, this, data);
            });
        })
            .catch((err) => {
            this.handleTokenRetrievalError(err);
        });
    }
    getRetryConnectionParams() {
        return {
            server: this.server,
            apiServer: this.apiServer,
            deviceName: this.deviceName,
            humanCode: this.machineCode
        };
    }
    setConnectionParamsAndRetry() {
        this.provisioningConnectionRetry(this.getRetryConnectionParams());
    }
    formActiveHoursErrorMessage(nextConnectTime) {
        let str = internal_1.chrome.i18n.getMessage('active_hours_restriction') ||
            'Active hours restriction. Reconnecting at {reconnect_time}';
        if (nextConnectTime) {
            str = str.replace('{reconnect_time}', nextConnectTime);
        }
        return str;
    }
    formTokenRetrievalError(status) {
        let str = internal_1.chrome.i18n.getMessage('token_retrieval_error') ||
            'Error retrieving token. Status: {status}';
        if (status) {
            str = str.replace('{status}', status);
        }
        return str;
    }
    handleTokenRetrievalError(err) {
        // From AccessToken.getAccessToken()
        this.logMessage('handleTokenRetrievalError(): Error calling getAccessToken: ' +
            JSON.stringify(err));
        this.setConnectedState(defs_1.ConnectionStateEnum.Disconnected);
        if (err) {
            if (err.halt) {
                pubsub_js_1.default.publish('onAppHalt');
                this.logError('handleTokenRetrievalError(): HALTING.');
                return;
            }
            if (err.status) {
                if (err.status === 410) {
                    // LSA-959: Token may have been expired but subsequent attempt to refresh
                    // gave a 410, meaning the device has been deleted. Initiate reprovisioning.
                    this.logWarning('handleTokenRetrievalError(): Status from getNewAccessToken() shows device was deleted. Attempting reprovision.');
                    internal_1.AccessToken.clearToken(() => {
                        this.setConnectionParamsAndRetry();
                    });
                }
                else if ((err.status === 403 || err.status === 503) &&
                    err.hasOwnProperty('nextConnectTime')) {
                    pubsub_js_1.default.publish('onTokenStatus', {
                        validToken: false,
                        error: this.formActiveHoursErrorMessage(new Date(parseInt(err.nextConnectTime)).toString())
                    });
                    this.setNextConnectTime(err.nextConnectTime);
                    this.setConnectionParamsAndRetry();
                }
                else if (err.status === 400) {
                    // The server couldn't even properly check the token. This means there's something wrong with our keys, i.e. the private key and
                    // public key won't work with each other. The more likely scenario is described in LSA-1411 where a user has provisioned with one
                    // version of the app, then changed to a different version, then went back to the original version. The original version will
                    // find the original keypair but it won't match what's on the server so the server's token checking will fail.
                    this.logWarning('handleTokenRetrievalError(): Received a 400 result. Attempting reprovision.');
                    internal_1.AccessToken.clearToken(() => {
                        this.setConnectionParamsAndRetry();
                    });
                }
                else {
                    pubsub_js_1.default.publish('onTokenStatus', {
                        validToken: false,
                        error: this.formTokenRetrievalError(err.status)
                    });
                    internal_1.AccessToken.clearToken(() => {
                        this.logError('onTokenError(): Received error ' +
                            err.status +
                            '. Running provisioning connection retry...');
                        this.setConnectionParamsAndRetry();
                    });
                }
            }
            else {
                // Some kind of generic error. Start doing retries.
                this.setConnectionParamsAndRetry();
            }
        }
    }
    publishConnectionChange() {
        const obj = {
            connected: this.connected,
            currentServer: this.server,
            lastError: this.lastError
        };
        this.controller.publishConnectionChange(this.idForController, obj);
    }
    provisioningConnectionRetry(connectionParams) {
        let timeInterval = 0;
        if (this.nextConnectTime >= 0) {
            timeInterval = 10000;
            this.logMessage('provisioningConnectionRetry(): Active hours restriction. Retrying connection in ' +
                timeInterval / 1000 +
                ' seconds');
            this.provisioningErrorAttempts = 0;
        }
        else {
            this.provisioningErrorAttempts++;
            this.logMessage('provisioningConnectionRetry(): Retrying connection in ' +
                (this.provisioningErrorAttempts - 1) * 10 +
                ' seconds');
            timeInterval = (this.provisioningErrorAttempts - 1) * 10000;
        }
        this.connectionRetryManager.doConnectionRetry(timeInterval, this, connectionParams);
    }
    setNextConnectTime(t) {
        this.logMessage('setNextConnectTime(): Setting nextConnectTime: ' + t);
        this.nextConnectTime = t;
    }
    onTokenError(status, param) {
        const connectionParams = param !== null && param !== void 0 ? param : this.getRetryConnectionParams();
        if (status === 410) {
            internal_1.AccessToken.clearToken(() => {
                this.logError('onTokenError(): Attempting reprovision with ' +
                    JSON.stringify(connectionParams) +
                    ' after ' +
                    this.provisioningErrorAttempts +
                    ' errors.');
                this.provisioningConnectionRetry(connectionParams);
            });
        }
        else if (status === 401) {
            internal_1.AccessToken.getNewAccessToken(this.apiServer)
                .then(() => {
                this.logMessage('onTokenError(): Successfully retrieved new access token.');
                this.setNextConnectTime(-1);
                this.provisioningErrorAttempts = 0;
                this.provisioningConnectionRetry(connectionParams);
            })
                .catch((err) => {
                this.handleTokenRetrievalError(err);
            });
        }
        else {
            this.provisioningConnectionRetry(connectionParams);
        }
    }
    setConnectedState(state) {
        //@ts-ignore
        this.connected = state;
        if (state === defs_1.ConnectionStateEnum.Connected) {
            this.provisioningErrorAttempts = 0;
            this.lastError = '';
        }
    }
    verifyTeacherMessage(data, callback) {
        this.teacherMessageVerifier.verifyMessage(data, (isVerified, payload) => {
            if (!isVerified) {
                pubsub_js_1.default.publish('onPayloadVerificationFailure');
            }
            // NOTE: Deleting type & destination from payload to main payload data type,
            // as they're used in sending correct message to desired destination,
            // and not used any further than that internally by client side code
            delete payload.type;
            delete payload.destination;
            callback(isVerified, payload);
        });
    }
    notifyController(data) {
        return new Promise((resolve, reject) => {
            if (this.controller) {
                this.logMessage('notifyController(): Notifying controller...');
                this.controller
                    .processSocketMessage(this.idForController, data)
                    .then((data) => {
                    resolve(data);
                })
                    .catch(() => {
                    reject();
                });
            }
            else {
                this.logMessage('notifyController(): No controller.');
                resolve(data);
            }
        });
    }
    fixClassDataWithLocalizedClassName(classData) {
        if (!classData || !classData.className) {
            throw new Error('SocketIOMsg.getClassNameLocalized(): No class data or no class name.');
        }
        if (classData.className === 'defaultMyFirstClass') {
            classData.className =
                internal_1.chrome.i18n.getMessage('default_my_first_class_localized') ||
                    'My First Class';
        }
        return classData;
    }
    publishJoinClass(data) {
        this.notifyController(data)
            .then((data) => {
            let joinClassMessage = data.joinClassMessage;
            try {
                let locClassData = this.fixClassDataWithLocalizedClassName(joinClassMessage);
                joinClassMessage = locClassData;
            }
            catch (err) {
                logger.logWarning('SocketIOMsg.publishJoinClass(): Error: ' + err);
            }
            pubsub_js_1.default.publish('onJoinClass', joinClassMessage);
            this.teacherMessageVerifier.reset();
            setHeartbeatTimer(0);
        })
            .catch(() => { });
    }
    publishLeaveClass(data) {
        this.notifyController(data)
            .then((data) => {
            pubsub_js_1.default.publish('onLeaveClass', data.leaveClassMessage);
            pubsub_js_1.default.publish('onStopMonitoring');
            this.teacherMessageVerifier.reset();
        })
            .catch(() => { });
    }
    formAuthError(data) {
        let str = internal_1.chrome.i18n.getMessage('token_auth_error') ||
            'Received authError from socket server: {error}';
        if (data) {
            str = str.replace('{error}', data);
        }
        return str;
    }
    publishSocketHandlerEvent(event, obj) {
        pubsub_js_1.default.publish('onSocketHandlerEvent', {
            event: event,
            data: obj
        });
    }
    logReceivedSocketMessage(msg, data) {
        this.logMessage("Received msg: '" + msg + "', data: " + JSON.stringify(data));
        this.publishSocketHandlerEvent(msg, data);
    }
    setupSocketIOHandlers() {
        if (!this.socketIO)
            return;
        this.socketIO.on('connect', () => {
            this.logReceivedSocketMessage('connect', {});
            this.needsManualConnect = false;
            this.logMessage("setupSocketIOHandlers(): Received 'connect'. SocketID = [" +
                (this.socketIO ? this.socketIO.id : '--NULL--') +
                ']. Authenticating with token: ' +
                JSON.stringify(this.accessToken));
            this.publishSocketHandlerEvent('authRequestSent', {});
            if (this.socketIO) {
                this.logAndEmit('authentication', {
                    accessToken: this.accessToken
                });
            }
            else {
                this.logError('*** SOCKET.IO IS NULL! Restarting agent in 15 seconds... ***');
                pubsub_js_1.default.publish('onCoreDumpLogs', {
                    ringBufferName: 'SIO'
                });
                setTimeout(() => {
                    if (this.controller) {
                        this.controller.restartAgent();
                    }
                }, 15000);
            }
        });
        this.socketIO.on('reconnect', () => {
            this.logReceivedSocketMessage('reconnect', {});
            this.controller.onSocketReconnect(this);
        });
        this.socketIO.on('authenticated', (auth) => {
            this.logReceivedSocketMessage('authenticated', auth);
            this.controller.onSocketAuthenticated(this, auth);
        });
        this.socketIO.on('authError', (obj) => {
            this.logReceivedSocketMessage('authError', obj);
            this.logError('Received authError: ' + JSON.stringify(obj));
            this.controller.onSocketAuthError(this, obj);
        });
        this.socketIO.on('error', (error) => {
            this.logReceivedSocketMessage('error', error);
            this.logError('*** SOCKET.IO ERROR ***' + JSON.stringify(error));
            if (this.metricAccumulator) {
                this.metricAccumulator.accumulateError({ errorCount: 1 });
            }
        });
        /* Reasons for disconnect according to socket.io.js-1.4.5:
            'transport close' -> ???
            'ping timeout' -> connection is lost / WiFi goes down
            'forced close' -> client closes the socket
            'transport error' -> socket error
            'io server disconnect' -> server disconnects the client
            'io client disconnect' -> client calls 'disconnect'
        */
        this.socketIO.on('disconnect', (reason) => {
            this.logReceivedSocketMessage('disconnect', reason);
            this.disconnectHandler(reason);
        });
        this.socketIO.on('connect_error', (data) => {
            this.logReceivedSocketMessage('connect_error', data);
            if (data) {
                if (data.type) {
                    this.lastError = data.type;
                }
                else if (typeof data === 'string') {
                    this.lastError = data;
                }
            }
            this.controller.onSocketConnectError(this, data);
        });
        this.socketIO.on('joinClass', (data) => {
            this.logReceivedSocketMessage('joinClass', data);
            this.publishJoinClass(data);
        });
        this.socketIO.on('leaveClass', (data) => {
            this.logReceivedSocketMessage('leaveClass', data);
            this.publishLeaveClass(data);
        });
        this.socketIO.on('checkClientPing', (data) => {
            var _a, _b, _c;
            this.logReceivedSocketMessage('checkClientPing', data);
            setHeartbeatTimer(0);
            const pong = {
                type: 'clientPong',
                clientPongMessage: {
                    socketId: (_b = (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : ''
                },
                socketId: (_c = this.socketIO) === null || _c === void 0 ? void 0 : _c.id,
                destination: this.controller.getSocketDestination()
            };
            this.postMessage(pong);
        });
        this.socketIO.on('publicKey', (data) => {
            this.logReceivedSocketMessage('publicKey', data);
            if (data.publicKeyMessage && data.publicKeyMessage.key) {
                pubsub_js_1.default.publish('onPublicKeyReceived', data);
                this.logMessage('Received public key from teacher: ' +
                    JSON.stringify(data.publicKeyMessage.key));
                this.teacherMessageVerifier.addPublicKey(data.publicKeyMessage.key);
            }
            else {
                this.logError("Received publicKey message from teacher but it's malformed!");
            }
        });
        this.socketIO.on('telemetry', (data) => {
            this.logReceivedSocketMessage('telemetry', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onTelemetryRequest', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'telemetry' message!");
            });
        });
        this.socketIO.on('limitState', (data) => {
            this.logReceivedSocketMessage('limitState', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onLimitState', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'limitState' message!");
            });
        });
        this.socketIO.on('remoteExecute', (data) => {
            this.logReceivedSocketMessage('remoteExecute', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onRemoteExecute', payload);
                    // TEST TEST TEST
                    // let tabIds = payload.remoteExecute.path.substring(7).split(',');
                    // payload.closeTabs = {
                    //     tabIds: tabIds
                    // };
                    // PubSub.publish('onCloseTabsRequest', payload);
                    // TEST TEST TEST
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'remoteExecute' message!");
            });
        });
        this.socketIO.on('currentScreen', (data) => {
            this.logReceivedSocketMessage('currentScreen', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onCurrentScreenRequest', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'currentScreen' message!");
            });
        });
        this.socketIO.on('heartbeat', (payload) => {
            pubsub_js_1.default.publish('onHeartbeatReceived', payload);
        });
        this.socketIO.on('IntelliTaskAssessment', (payload) => {
            this.logReceivedSocketMessage('IntelliTaskAssessment', payload);
            pubsub_js_1.default.publish('onIntelliTaskAssessmentReceived', payload);
        });
        this.socketIO.on('requestNewIntelliTaskAssessment', (data) => {
            this.logReceivedSocketMessage('requestNewIntelliTaskAssessment', data);
            pubsub_js_1.default.publish('onRequestNewIntelliTaskAssessment', data.payload);
        });
        this.socketIO.on('sendChat', (data) => {
            this.logReceivedSocketMessage('sendChat', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onChatReceived', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'sendChat' message!");
            });
        });
        this.socketIO.on('doNotDisturb', (data) => {
            this.logReceivedSocketMessage('doNotDisturb', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onDoNotDisturbReceived', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'doNotDisturb' message!");
            });
        });
        this.socketIO.on('clearRaiseHand', (data) => {
            this.logReceivedSocketMessage('clearRaiseHand', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onClearRaiseHand', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'clearRaiseHand' message!");
            });
        });
        this.socketIO.on('closeTabs', (data) => {
            this.logReceivedSocketMessage('closeTabs', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onCloseTabsRequest', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'closeTabs' message!");
            });
        });
        this.socketIO.on('screenShareStarted', (data) => {
            this.logReceivedSocketMessage('screenShareStarted', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onBeginViewBroadcast', payload.screenShareStartedMessage.conferenceData);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'screenShareStarted' message!");
            });
        });
        this.socketIO.on('chimeScreenShareStarted', (data) => {
            this.logReceivedSocketMessage('chimeScreenShareStarted', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    // Example meetingData:
                    // "meetingData": {
                    //     "meetingId": "359d9487-91e3-4c8e-a79c-b8d2ae4f2713",
                    //     "windowed": true
                    // }
                    pubsub_js_1.default.publish('onChimeScreenShareStarted', payload.chimeScreenShareStartedMessage.meetingData);
                    setHeartbeatTimer(0);
                }
                else {
                    this.logError("Verification failed for 'chimeScreenShareStarted' message!");
                }
            });
        });
        this.socketIO.on('screenShareEnded', (data) => {
            this.logReceivedSocketMessage('screenShareEnded', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onEndViewBroadcast', payload);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'screenShareEnded' message!");
            });
        });
        this.socketIO.on('audioCallStarted', (data) => {
            this.logReceivedSocketMessage('audioCallStarted', data);
            // FIXME: use payload here like all other socket messages
            this.verifyTeacherMessage(data, (verified) => {
                if (verified) {
                    pubsub_js_1.default.publish('onBeginAudioBroadcast', data.payload.audioCallStartedMessage.conferenceData);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'audioCallStarted' message!");
            });
        });
        this.socketIO.on('audioCallEnded', (data) => {
            this.logReceivedSocketMessage('audioCallEnded', data);
            // FIXME: use payload here like all other socket messages
            this.verifyTeacherMessage(data, (verified) => {
                if (verified) {
                    pubsub_js_1.default.publish('onEndAudioBroadcast', data);
                    setHeartbeatTimer(0);
                }
                else
                    this.logError("Verification failed for 'audioCallEnded' message!");
            });
        });
        this.socketIO.on('shareStudentScreenRequest', (data) => {
            this.logReceivedSocketMessage('shareStudentScreenRequest', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onShareStudentScreenRequest', payload);
                    setHeartbeatTimer(0);
                }
                else {
                    this.logError("Verification failed for 'shareStudentScreenRequest' message!");
                }
            });
        });
        this.socketIO.on('cancelStudentScreenShareRequest', (data) => {
            this.logReceivedSocketMessage('cancelStudentScreenShareRequest', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onCancelStudentScreenShareRequest', payload);
                    setHeartbeatTimer(0);
                }
                else {
                    this.logError("Verification failed for 'cancelStudentScreenShareRequest' message!");
                }
            });
        });
        this.socketIO.on('startStudentScreenViewBroadcast', (data) => {
            this.logReceivedSocketMessage('startStudentScreenViewBroadcast ', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onStartStudentScreenViewBroadcast', payload);
                    setHeartbeatTimer(0);
                }
                else {
                    this.logError("Verification failed for 'startStudentScreenViewBroadcast' message!");
                }
            });
        });
        this.socketIO.on('endStudentScreenViewBroadcast', (data) => {
            this.logReceivedSocketMessage('endStudentScreenViewBroadcast', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onEndStudentScreenViewBroadcast', payload);
                    setHeartbeatTimer(0);
                }
                else {
                    this.logError("Verification failed for 'endStudentScreenViewBroadcast' message!");
                }
            });
        });
        this.socketIO.on('conferenceAttendeeNames', (data) => {
            this.logReceivedSocketMessage('conferenceAttendeeNames', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onConferenceAttendeeNames', payload);
                    setHeartbeatTimer(0);
                }
            });
        });
        this.socketIO.on('activeInstructorsInfo', (data) => {
            this.logReceivedSocketMessage('activeInstructorsInfo', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onActiveInstructorsInfo', payload);
                    setHeartbeatTimer(0);
                }
            });
        });
        this.socketIO.on('closeApp', (data) => {
            this.logReceivedSocketMessage('closeApp', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onCloseApp', payload);
                    setHeartbeatTimer(0);
                }
            });
        });
        this.socketIO.on('sendWebHistory', (data) => {
            this.logReceivedSocketMessage('sendWebHistory', data);
            this.verifyTeacherMessage(data, (verified, payload) => {
                if (verified) {
                    pubsub_js_1.default.publish('onSendWebHistory', payload);
                    setHeartbeatTimer(0);
                }
            });
        });
    }
    getDeviceIDFromParams() {
        var _a;
        const provisioningData = preferences.getSetting('provisioningData');
        if (provisioningData && provisioningData.deviceID) {
            return (_a = provisioningData.deviceID) !== null && _a !== void 0 ? _a : '';
        }
        throw new Error('deviceID missing from provisioningData');
    }
    /**  functions **/
    connect(data) {
        var _a;
        this.studentDbId = data.device_db_id;
        this.orgName = data.vanity_name;
        this.orgId = data.org_id;
        this.server = data.server;
        this.apiServer = data.apiServer;
        this.teacherMessageVerifier.reset();
        this.accessToken = data.accessToken;
        this.logMessage('connect(+)');
        if (this.needsManualConnect === undefined) {
            this.logMessage('connect(): needsManualConnect undefined');
            this.needsManualConnect = true;
        }
        // Don't call the io.connect again if we are already connected.
        if (this.needsManualConnect === false) {
            this.logMessage('connect(): No manual reconnect needed');
            return;
        }
        this.logMessage('connect(): Doing manual connection...');
        (_a = this.controller) === null || _a === void 0 ? void 0 : _a.getConnectHeaders(this.deviceName).then((connectHeaders) => {
            if (connectHeaders) {
                try {
                    this.socketIO = (0, socket_io_client_1.default)(this.server, connectHeaders);
                }
                catch (err) {
                    this.logError('connect() error: ' + err);
                }
            }
            else {
                this.logWarning('connect(): No connect headers.');
                this.socketIO = (0, socket_io_client_1.default)(this.server);
            }
            this.logMessage('connect(): Setting up socket handlers...');
            this.setupSocketIOHandlers();
        });
    }
    disconnect(forceDisconnect = false) {
        this.logMessage('disconnect(+)');
        let isConnected = false;
        if (this.socketIO) {
            if (this.socketIO.disconnected) {
                if (!forceDisconnect) {
                    this.logMessage('disconnect(): We\'re already disconnected. Exiting.');
                    return;
                }
                else {
                    this.logMessage('disconnect(): We\'re already disconnected but the directive is to force close.');
                }
            }
            isConnected = this.socketIO.connected;
            this.logMessage('disconnect(): Current socket connected: ' + isConnected);
            this.socketIO.disconnect();
            this.socketIO.removeAllListeners();
            this.socketIO = undefined;
        }
        return isConnected;
    }
    disconnectHandler(reason) {
        this.logMessage('disconnectHandler(+) (' + reason + ')');
        this.needsManualConnect = this.controller.onSocketDisconnect(this, reason);
        if (!this.needsManualConnect) {
            this.logMessage('on disconnect(): Not manually retrying connection');
            return;
        }
        const connectionParams = {
            server: this.server,
            apiServer: this.LStudent.apiServer,
            deviceName: this.deviceName,
            humanCode: this.machineCode
        };
        this.logMessage('on disconnect(): Retrying connection soon with ' +
            JSON.stringify(connectionParams));
        this.connectionRetryManager.doConnectionRetry(10000, this, connectionParams);
    }
    destroy() {
        this.disconnect(true);
    }
    postChatMessage(chatObj) {
        var _a;
        const chat = {
            type: 'sendChat',
            sendChatMessage: {
                classID: chatObj.classID,
                className: chatObj.className,
                activeClassID: chatObj.activeClassID,
                loginName: chatObj.loginName,
                studentFullName: chatObj.studentFullName,
                chatHistoryEnabled: chatObj.chatHistoryEnabled,
                sendTime: chatObj.timestamp,
                message: chatObj.message
            },
            socketId: (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id,
            destination: this.controller.getSocketDestination()
        };
        this.postMessage(chat);
    }
    postRaiseHand(raiseHandObj, loginName) {
        var _a, _b, _c, _d;
        if (raiseHandObj.handRaised) {
            const rhm = new internal_1.RaiseHandMessage();
            rhm.raiseHandMessage = {
                sendTime: raiseHandObj.timestamp,
                loginName: loginName
            };
            rhm.socketId = (_b = (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
            rhm.clearRaiseHandMessage = undefined;
            rhm.destination = this.controller.getSocketDestination();
            this.postMessage(rhm);
        }
        else {
            const crm = new internal_1.ClearRaiseHandMessage();
            crm.clearRaiseHandMessage = {
                sendTime: raiseHandObj.timestamp,
                loginName: loginName
            };
            crm.socketId = (_d = (_c = this.socketIO) === null || _c === void 0 ? void 0 : _c.id) !== null && _d !== void 0 ? _d : '';
            crm.destination = this.controller.getSocketDestination();
            this.postMessage(crm);
        }
    }
    postTelemetryMessage(telemetryObj) {
        var _a, _b;
        const currentTelemetry = {
            type: TelemetryMessageType,
            currentTelemetryMessage: {},
            destination: this.controller.getSocketDestination(),
            socketId: (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id,
            timestamp: logger.timeStampMS(true),
            loginName: this.LStudent.emailAddr,
            studentName: this.LStudent.displayName,
            machineName: (_b = this.LStudent.machineName) !== null && _b !== void 0 ? _b : '',
            deviceID: '(unknown)'
        };
        try {
            currentTelemetry.deviceID = this.getDeviceIDFromParams();
        }
        catch (e) {
            this.logError('postTelemetryMessage error: ' + e);
            currentTelemetry.deviceID = '(unknown)';
        }
        if (telemetryObj.waitingForFullScreenPermission) {
            currentTelemetry.currentTelemetryMessage.waitingForFullScreenPermission =
                telemetryObj.waitingForFullScreenPermission;
        }
        if (telemetryObj.activeTabFailure) {
            currentTelemetry.currentTelemetryMessage.activeTabFailure =
                telemetryObj.activeTabFailure;
        }
        if (telemetryObj.thumbnail) {
            currentTelemetry.currentTelemetryMessage.thumbnail =
                telemetryObj.thumbnail;
        }
        if (telemetryObj.battery) {
            currentTelemetry.currentTelemetryMessage.battery =
                telemetryObj.battery;
        }
        if (telemetryObj.currentWebsite && telemetryObj.currentWebsite.url) {
            currentTelemetry.currentTelemetryMessage.currentWebsite =
                telemetryObj.currentWebsite;
        }
        if (telemetryObj.browserWindows) {
            currentTelemetry.currentTelemetryMessage.browserWindows =
                telemetryObj.browserWindows;
        }
        if (telemetryObj.runningApps) {
            currentTelemetry.currentTelemetryMessage.runningApps =
                telemetryObj.runningApps;
        }
        if (telemetryObj.attendeeId) {
            currentTelemetry.currentTelemetryMessage.attendeeId =
                telemetryObj.attendeeId;
        }
        this.postMessage(currentTelemetry);
    }
    postCurrentScreenMessage(currentScreenObj) {
        var _a, _b;
        const currentScreen = {
            type: CurrentScreenMessageType,
            currentScreenMessage: {
                size: {
                    width: currentScreenObj.width || 0,
                    height: currentScreenObj.height || 0
                },
                image: {
                    data: currentScreenObj.data || '',
                    type: currentScreenObj.dataType || ''
                },
                activeTabFailure: currentScreenObj.activeTabFailure
            },
            destination: this.controller.getSocketDestination(),
            socketId: (_b = (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : ''
        };
        // if (currentScreenObj.activeTabFailure) {
        //     currentScreen.currentScreenMessage.activeTabFailure =
        //         currentScreenObj.activeTabFailure;
        // }
        this.postMessage(currentScreen);
    }
    postShareStudentScreenResponse(shareStudentScreenData) {
        var _a, _b;
        const shareStudentScreenResponse = Object.assign({ type: 'shareStudentScreenResponse' }, shareStudentScreenData);
        shareStudentScreenResponse.socketId = (_b = (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        shareStudentScreenResponse.destination = this.controller.getSocketDestination();
        this.postMessage(shareStudentScreenResponse);
    }
    postStopStudentScreenBroadcast(stopStudentScreenData) {
        var _a, _b;
        const stopStudentScreenBroadcast = Object.assign({ type: 'stopStudentScreenBroadcast' }, stopStudentScreenData);
        stopStudentScreenBroadcast.socketId = (_b = (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
        stopStudentScreenBroadcast.destination = this.controller.getSocketDestination();
        this.postMessage(stopStudentScreenBroadcast);
    }
    determineSocketSigning(onCompleted) {
        this.teacherMessageVerifier.setSigningRequirements(defs_1.SigningRequirementEnum.Enforced);
        if (onCompleted)
            onCompleted();
    }
    getTeacherRoomFromStudentRoom(studentRoom) {
        const teacherRoom = studentRoom.replace(/-S$/, '-T');
        return teacherRoom;
    }
    joinRoom(room, osVersion) {
        this.determineSocketSigning(() => {
            this.postMessage();
        });
        const teacherRoom = this.getTeacherRoomFromStudentRoom(room);
        this.logMessage('Teacher room is: ' + teacherRoom);
        this.postMessage({
            type: 'join',
            joinMessage: {
                studentRoom: room,
                teacherRoom: teacherRoom
            },
            application: 'lanschool',
            loginName: this.LStudent.emailAddr,
            deviceID: internal_1.UserInfoRetriever.getDeviceID(),
            os: osVersion
        });
    }
    requestPublicKey(room) {
        var _a, _b;
        if (!((_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id)) {
            // When this is first called, the socket connection has started but probably hasn't completed yet.
            // But also sending this message when there is no socket id yet is useless, so skip this call if there
            // is no id.  If the client doesn't get the public key in time, this will get called again and by then
            // the socket should have been fully connected.  Moving this to a different part of the join process
            // would allow the first call to go through, but I think is too risky to consider. - MattJ
            this.logMessage('requestPublicKey: No socket id yet - returning');
            return;
        }
        const teacherRoom = this.getTeacherRoomFromStudentRoom(room);
        this.logMessage('requestPublicKey: Teacher room is: ' + teacherRoom);
        this.postMessage({
            type: 'getPublicKey',
            destination: teacherRoom,
            studentSocketID: (_b = this.socketIO) === null || _b === void 0 ? void 0 : _b.id
        });
    }
    leaveRoom(leaveRoomObj) {
        this.postMessage({
            type: 'leave',
            leaveMessage: {
                room: leaveRoomObj.studentRoom || '',
                teacherRoom: leaveRoomObj.teacherRoom || '',
                data: {
                    newClassId: leaveRoomObj.newClassId || '',
                    newClassName: leaveRoomObj.newClassName || '',
                    teacher: {
                        firstName: leaveRoomObj.newTeacherInfo.firstName || '',
                        lastName: leaveRoomObj.newTeacherInfo.lastName || ''
                    },
                    student: {
                        deviceId: internal_1.UserInfoRetriever.getDeviceID()
                    }
                }
            }
        });
        this.teacherMessageVerifier.reset();
        this.logMessage('leaveRoom(): Leaving room. Clearing xmit messages.');
        this.xmitQueue = [];
    }
    lookup(lookupObj) {
        const lookupMsg = {
            type: 'lookup',
            application: 'lanschool',
            loginName: lookupObj.loginName,
            emailAddress: lookupObj.emailAddr,
            studentName: lookupObj.studentName,
            domainName: lookupObj.domainName,
            deviceID: lookupObj.deviceID,
            machineName: lookupObj.machineName,
            classSocketSupport: lookupObj.classSocketSupport,
            clientVersion: lookupObj.clientVersion
        };
        this.logMessage('lookup(): looking up classes based on lookup object: ' +
            JSON.stringify(lookupMsg));
        this.postMessageNoQueue(lookupMsg);
    }
    postMessage(msg) {
        if (msg)
            this.xmitQueue.push(msg);
        if (this.teacherMessageVerifier.getSigningRequirements() !==
            defs_1.SigningRequirementEnum.Unknown &&
            //@ts-ignore
            this.connected === defs_1.ConnectionStateEnum.Connected) {
            // Dequeue waiting outgoing messages
            while (this.xmitQueue.length > 0) {
                var dequeued = this.xmitQueue.shift();
                this.postMessageNoQueue(dequeued);
            }
        }
        else {
            if (msg) {
                this.logWarning('postMessage(): Queueing msg ' +
                    this.getLoggableStringForMessage(msg));
            }
        }
    }
    postFromMessageFactory(messageFactory) {
        var _a;
        try {
            const factoryMsg = messageFactory.getMessage();
            const payload = {};
            factoryMsg.forEach((param) => {
                payload[param.name] = param.value;
            });
            payload["socketId"] = (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.id;
            payload["destination"] = this.controller.getSocketDestination();
            this.postMessage(payload);
        }
        catch (e) {
            this.logWarning(`SocketIOMsg.postFromMessageFactory(): ${e === null || e === void 0 ? void 0 : e.message}`);
        }
    }
    postMessageNoQueue(msg) {
        if (!msg || !msg.type) {
            this.logMessage('postMessageNoQueue(): Not posting unknown msg. Missing type?');
            return;
        }
        if (this.socketIO === null || this.socketIO === undefined) {
            this.logMessage('postMessageNoQueue(): socketio not ready!');
            return;
        }
        if (!this.shouldOutgoingMessageTypeBeSigned(msg.type)) {
            let sendObj = {
                payload: msg
            };
            this.emitObject(sendObj);
            return;
        }
        let strMsg = JSON.stringify(msg);
        let msgDestination = msg.destination;
        let msgType = msg.type;
        internal_1.PKI.signPayload(internal_1.PKI.str2ab(strMsg)).then((signature) => {
            let sendObj = {
                payload: strMsg,
                signed: (0, internal_1.ArrayBufferToBase64Ex)(signature)
            };
            if (msgDestination) {
                sendObj.destination = msgDestination;
            }
            if (msgType) {
                sendObj.type = msgType;
            }
            this.emitObject(sendObj);
        });
    }
    emitObject(sendObj) {
        this.logAndEmit('fromClient', sendObj);
        if (this.metricAccumulator) {
            this.metricAccumulator.accumulate(sendObj);
        }
    }
    shouldOutgoingMessageTypeBeSigned(msgType) {
        if (this.unsignedOutgoingMessageTypes.includes(msgType)) {
            return false;
        }
        return true;
    }
    isTelemetryMessage(obj) {
        return obj && obj.type && obj.type === TelemetryMessageType;
    }
    isCurrentScreenMessage(obj) {
        return obj && obj.type && obj.type === CurrentScreenMessageType;
    }
    isIntellitaskMessage(obj) {
        return obj && obj.type && obj.type === IntellitaskMessageType;
    }
    getTruncatedTelemetryMessage(obj) {
        var _a, _b, _c;
        if (this.isTelemetryMessage(obj)) {
            let copy = JSON.parse(JSON.stringify(obj));
            let temp = JSON.parse(copy.payload);
            const imageData = (_c = (_b = (_a = temp === null || temp === void 0 ? void 0 : temp.currentTelemetryMessage) === null || _a === void 0 ? void 0 : _a.thumbnail) === null || _b === void 0 ? void 0 : _b.image) === null || _c === void 0 ? void 0 : _c.data;
            if (imageData && imageData.length > 80) {
                const truncated = imageData.substring(0, 35) +
                    '...' +
                    imageData.substring(imageData.length - 35);
                temp.currentTelemetryMessage.thumbnail.image.data = truncated;
                copy.payload = JSON.stringify(temp);
                return copy;
            }
        }
        return obj;
    }
    getTruncatedCurrentScreenMessage(obj) {
        var _a, _b;
        if (this.isCurrentScreenMessage(obj)) {
            const copy = JSON.parse(JSON.stringify(obj));
            const temp = JSON.parse(copy.payload);
            const imageData = (_b = (_a = temp === null || temp === void 0 ? void 0 : temp.currentScreenMessage) === null || _a === void 0 ? void 0 : _a.image) === null || _b === void 0 ? void 0 : _b.data;
            if (imageData && imageData.length > 80) {
                const truncated = imageData.substring(0, 35) +
                    '...' +
                    imageData.substring(imageData.length - 35);
                temp.currentScreenMessage.image.data = truncated;
                copy.payload = JSON.stringify(temp);
                return copy;
            }
        }
        return obj;
    }
    getTruncatedIntellitaskMessage(obj) {
        var _a, _b, _c;
        if (this.isIntellitaskMessage(obj)) {
            const copy = JSON.parse(JSON.stringify(obj));
            const temp = JSON.parse(copy.payload);
            const imageData = (_c = (_b = (_a = temp === null || temp === void 0 ? void 0 : temp.intelliTaskMessage) === null || _a === void 0 ? void 0 : _a.image) === null || _b === void 0 ? void 0 : _b.image) === null || _c === void 0 ? void 0 : _c.data;
            if (imageData && imageData.length > 80) {
                const truncated = imageData.substring(0, 35) +
                    '...' +
                    imageData.substring(imageData.length - 35);
                temp.intelliTaskMessage.image.image.data = truncated;
                copy.payload = JSON.stringify(temp);
                return copy;
            }
        }
        return obj;
    }
    getLoggableStringForMessageOld(obj) {
        let lenLimit = -1;
        if (this.isTelemetryMessage(obj) || this.isCurrentScreenMessage(obj)) {
            lenLimit = 200;
        }
        let stringifiedObj = JSON.stringify(obj);
        if (lenLimit > 0 && stringifiedObj.length > lenLimit) {
            stringifiedObj = stringifiedObj.substring(0, lenLimit) + '...';
        }
        return stringifiedObj;
    }
    getLoggableStringForMessage(obj) {
        try {
            obj = this.getTruncatedTelemetryMessage(obj);
            obj = this.getTruncatedCurrentScreenMessage(obj);
            obj = this.getTruncatedIntellitaskMessage(obj);
            return JSON.stringify(obj);
        }
        catch (e) {
            this.logError('Exception getting loggable string: ' + e);
        }
        return this.getLoggableStringForMessageOld(obj);
    }
    getPayloadType(obj) {
        if (obj && obj.payload && obj.payload.type) {
            // This isn't going to be super useful for any signed messages because
            // "type" has been stringified at this point. But for now, we're just using
            // it to know when the "join" message is being emitted, which isn't signed.
            return obj.payload.type;
        }
        return null;
    }
    logAndEmit(eventName, obj) {
        var _a, _b, _c;
        const isTelemetryMsg = this.isTelemetryMessage(obj);
        if (isTelemetryMsg) {
            this.logMessage('Emitting volatile [' +
                eventName +
                '] => ' +
                this.getLoggableStringForMessage(obj));
            (_b = (_a = this.socketIO) === null || _a === void 0 ? void 0 : _a.volatile) === null || _b === void 0 ? void 0 : _b.emit(eventName, obj);
        }
        else {
            this.logMessage('Emitting [' +
                eventName +
                '] => ' +
                this.getLoggableStringForMessage(obj));
            (_c = this.socketIO) === null || _c === void 0 ? void 0 : _c.emit(eventName, obj);
        }
        pubsub_js_1.default.publish('onSocketMessageEmitted', {
            event: eventName,
            payloadType: this.getPayloadType(obj)
        });
    }
    getLogPreamble() {
        return 'SocketIOMsg(' + this.idForController + ')';
    }
    logDebug(msg) {
        logger.logDebug(this.getLogPreamble() + ': ' + msg);
    }
    logMessage(msg) {
        logger.logMessage(this.getLogPreamble() + ': ' + msg);
    }
    logWarning(msg) {
        logger.logWarning(this.getLogPreamble() + ': ' + msg);
    }
    logError(msg) {
        logger.logError(this.getLogPreamble() + ': ' + msg);
    }
}
exports.SocketIOMsg = SocketIOMsg;
//# sourceMappingURL=socketIOMessage.js.map