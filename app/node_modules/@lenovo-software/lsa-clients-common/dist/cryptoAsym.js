"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoUtil = exports.CryptoAsym = void 0;
const internal_1 = require("./internal");
const publicKeyPreamble = '-----BEGIN PUBLIC KEY-----';
const publicKeyEpilogue = '-----END PUBLIC KEY-----';
const privateKeyPreamble = '-----BEGIN PRIVATE KEY-----';
const privateKeyEpilogue = '-----END PRIVATE KEY-----';
class CipherText {
    constructor(_encryptedAesKey, _iv, _cipherTextBody) {
        this._encryptedAesKey = _encryptedAesKey;
        this._iv = _iv;
        this._cipherTextBody = _cipherTextBody;
    }
    get encryptedAesKey() {
        return this._encryptedAesKey;
    }
    get iv() {
        return this._iv;
    }
    get cipherTextBody() {
        return this._cipherTextBody;
    }
    toString() {
        return (this._encryptedAesKey + ':' + this._iv + ':' + this._cipherTextBody);
    }
    static fromString(cipherText) {
        // Divide up the encrypted key from the actual encrypted text
        const strComposite = cipherText.split(':');
        if (strComposite.length !== 3) {
            throw new Error('Ciphertext malformed.');
        }
        return new CipherText(strComposite[0], strComposite[1], strComposite[2]);
    }
}
/**
 * This class will produce ciphertext or plaintext based on a private/public keypair. The private key must be
 * in PKCS#8 format. You can encrypt using either key as long as you decrypt with the other key. Due to the
 * nature of RSA encryption being unable to encrypt large amounts of text, the text body is actually encrypted
 * using AES-GCM. The AES key is encrypted using the indicated RSA key with the RSA-OAEP algorithm. At
 * decryption time, the process is reversed.
 *
 * If creating the keypair with openssl, use the following commands:
 * To create the RSA private key:
 *     openssl genrsa -out key.pem 2048
 *
 * To create the corresponding public key:
 *     openssl rsa -in ./key.pem -outform PEM -pubout -out public.pem
 *
 * To create the corresponding private key in PKCS#8 format:
 *     openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in key.pem -out pkcs8.pem

 * The ciphertext produced has three parts, each Base64-encoded and colon-delimited:
 *   1. The key used to encrypt the text, encrypted with one of the keys in the keypair.
 *   2. A 12-byte initialization vector.
 *   3. The ciphertext body.
 *
 * At decryption time, these are teased apart and, assuming the key is a match, the text body is decrypted
 * using the other key given in the keypair.
 *
 */
class CryptoAsym {
    constructor() {
        this._crypto = internal_1.LSAClient.getInstance().cryptoSubtleCallback;
    }
    async initEncryptionKey() {
        this.key = await this._crypto.generateKey({
            name: 'AES-GCM',
            length: 256
        }, true, ['encrypt']);
    }
    /**
     *
     * @param pem Base64-encoded string containing the private key.
     *   The preamble and epilogue should already have been removed.
     * @returns Promise with CryptoKey
     */
    async importPrivateKey(pem, keyUses) {
        const abKey = (0, internal_1.Base64ToArrayBufferEx)(pem);
        const ck = await this._crypto.importKey('pkcs8', abKey, {
            name: 'RSA-OAEP',
            hash: { name: 'SHA-256' }
        }, false, keyUses);
        return ck;
    }
    /**
     *
     * @param pem Base64-encoded string containing the private key.
     *   The preamble and epilogue should already have been removed.
     * @returns Promise with CryptoKey
     */
    importPublicKey(pem, keyUses) {
        const abKey = (0, internal_1.Base64ToArrayBufferEx)(pem);
        return this._crypto.importKey('spki', abKey, {
            name: 'RSA-OAEP',
            hash: { name: 'SHA-256' }
        }, false, keyUses);
    }
    /**
     *
     * @param pem Either the public or private key. The type of key is determined
     * by the inclusion of "PRIVATE KEY" in the preamble string.
     * @returns Promise with CryptoKey
     */
    importKey(pem, keyUses) {
        const isPrivateKey = pem.includes(privateKeyPreamble);
        // Remove preamble/epilogues/whitespace
        pem = pem
            .replace(publicKeyEpilogue, '')
            .replace(privateKeyEpilogue, '')
            .replace(publicKeyPreamble, '')
            .replace(privateKeyPreamble, '')
            .replace(/\s+/g, '');
        return isPrivateKey
            ? this.importPrivateKey(pem, keyUses)
            : this.importPublicKey(pem, keyUses);
    }
    /**
     *
     * @param rsaEncryptionKey Base64-encoded RSA key used to encrypt the AES key.
     * @returns ArrayBuffer containing the encrypted AES key.
     */
    async getEncryptedAesKey(rsaEncryptionKey) {
        const encryptKey = await this.importKey(rsaEncryptionKey, ['encrypt']);
        const exportedKey = await this._crypto.exportKey('raw', this.key);
        return this._crypto.encrypt({ name: 'RSA-OAEP' }, encryptKey, exportedKey);
    }
    /**
     *
     * @param rsaDecryptionKey Base64-encoded RSA key which will be used to decrypt the AES key.
     * @param encryptedAesKey ArrayBuffer containing the encrypted AES key.
     * @returns Promise with CryptoKey containing the AES key.
     */
    async getDecryptedAesKey(rsaDecryptionKey, encryptedAesKey) {
        const decryptionKey = await this.importKey(rsaDecryptionKey, [
            'decrypt'
        ]);
        const abPlaintextAesKey = await this._crypto.decrypt({ name: 'RSA-OAEP' }, decryptionKey, encryptedAesKey);
        return this._crypto.importKey('raw', abPlaintextAesKey, 'AES-GCM', false, ['decrypt']);
    }
    /**
     *
     * @param plaintext The string to encrypt.
     * @param rsaKey The RSA key used in the encryption process.
     * @returns Promise with a string containing the ciphertext header and body.
     */
    async encrypt(plaintext, rsaKey) {
        const enc = new TextEncoder();
        if (!this.key) {
            this.initEncryptionKey();
        }
        const encryptedAesKey = await this.getEncryptedAesKey(rsaKey);
        const iv = this._crypto.getRandomValues(new Uint8Array(12));
        const abCipherText = await this._crypto.encrypt({ name: 'AES-GCM', iv: iv }, this.key, enc.encode(plaintext));
        return new CipherText((0, internal_1.ArrayBufferToBase64Ex)(encryptedAesKey), (0, internal_1.ArrayBufferToBase64Ex)(iv), (0, internal_1.ArrayBufferToBase64Ex)(abCipherText)).toString();
    }
    /**
     *
     * @param cipherText The cipertext header and body to decrypt.
     * @param rsaKey The RSA key used in the decryption process.
     * @returns Promise with a string containing the original plaintext.
     */
    async decrypt(cipherText, rsaKey) {
        const ct = CipherText.fromString(cipherText);
        const decryptedAesKey = await this.getDecryptedAesKey(rsaKey, (0, internal_1.Base64ToArrayBufferEx)(ct.encryptedAesKey));
        const iv = (0, internal_1.Base64ToArrayBufferEx)(ct.iv);
        const decryptedAB = await this._crypto.decrypt({ name: 'AES-GCM', iv: iv }, decryptedAesKey, (0, internal_1.Base64ToArrayBufferEx)(ct.cipherTextBody));
        const enc = new TextDecoder();
        return Promise.resolve(enc.decode(decryptedAB));
    }
}
exports.CryptoAsym = CryptoAsym;
class CryptoUtil {
    constructor() {
        this._crypto = internal_1.LSAClient.getInstance().cryptoSubtleCallback;
    }
    async pkcs8ToJWKString(pem) {
        let pemContents = pem;
        if (pem.includes(privateKeyPreamble) &&
            pem.includes(privateKeyEpilogue)) {
            pemContents = pem.substring(privateKeyPreamble.length, pem.length - privateKeyEpilogue.length);
        }
        const binaryDerString = Buffer.from(pemContents, 'base64').toString('binary');
        // Convert the binary string to an ArrayBuffer
        const binaryDer = new Uint8Array(binaryDerString.length);
        for (let i = 0; i < binaryDerString.length; i++) {
            binaryDer[i] = binaryDerString.charCodeAt(i);
        }
        const privateKey = await this._crypto.importKey('pkcs8', binaryDer, {
            name: 'RSASSA-PKCS1-v1_5',
            hash: 'SHA-256',
            modulusLength: 2048,
            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
            privateKey: true
        }, true, ['sign', 'verify']);
        const jwk = await this._crypto.exportKey('jwk', privateKey);
        return JSON.stringify(jwk);
    }
}
exports.CryptoUtil = CryptoUtil;
//# sourceMappingURL=cryptoAsym.js.map