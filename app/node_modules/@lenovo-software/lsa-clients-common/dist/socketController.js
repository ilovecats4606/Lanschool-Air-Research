"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoinMessageRetryTimer = exports.SocketController = exports.GetPublicKeyMessageRetryTimer = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const defs_1 = require("./js/defs");
const internal_1 = require("./internal");
const ControlSocketId = 0;
const ClassSocketId = 1;
const SocketDestinationUndefined = '[UNDEFINED]';
const GetPublicKeyMessageResponseTimeout = 3000;
const GetPublicKeyMessageResponseRetryMax = 5;
const JoinMessageResponseTimeout = 3000;
const JoinMessageResponseRetryMax = 5;
const logger = new internal_1.LoggerInterop();
class GetPublicKeyMessageRetryTimer {
    constructor() {
        this.executionsLeft = GetPublicKeyMessageResponseRetryMax;
        pubsub_js_1.default.subscribe('onPublicKeyReceived', (msg, data) => {
            this.reset();
        });
    }
    execute() {
        if (this.executionsLeft > 0) {
            logger.logMessage('GetPublicKeyMessageRetryTimer.execute(): Executing callback. Executions remaining: ' +
                this.executionsLeft);
            if (this.cb)
                this.cb();
            this.executionsLeft--;
            // this timer used to be set when catching a join message being emitted from the
            // client.  this doesn't work the same when emitting the new getPublicKey socket
            // message.  I decided to remove the subscription of the emitting event handler
            // and just set the timer here; it works the same and I think is simpler
            this.waitTimer = setTimeout(this.execute.bind(this), GetPublicKeyMessageResponseTimeout);
        }
        else {
            logger.logWarning('GetPublicKeyMessageRetryTimer.execute(): Ran out of executions.');
            if (this.waitTimer) {
                clearTimeout(this.waitTimer);
                this.waitTimer = null;
            }
        }
    }
    setCallback(callback) {
        this.cb = callback;
        this.execute();
    }
    reset() {
        logger.logDebug('GetPublicKeyMessageRetryTimer.reset(+)');
        if (this.waitTimer) {
            logger.logMessage('GetPublicKeyMessageRetryTimer.reset(): Cancelling timer.');
            clearTimeout(this.waitTimer);
            this.waitTimer = null;
        }
        this.executionsLeft = GetPublicKeyMessageResponseRetryMax;
    }
}
exports.GetPublicKeyMessageRetryTimer = GetPublicKeyMessageRetryTimer;
class SocketController {
    constructor(controllerObj) {
        this.classSocketDestination = SocketDestinationUndefined;
        this.classSocketUrl = '';
        this.classSocketTarget = '';
        this.targetedClassSocket = false;
        this.isInClass = false;
        this.controlSocketNeedsManualReconnect = false;
        this.leaveClassCallback = null;
        logger.logMessage('SocketController(+)');
        this.setDefaults();
        this.sioParam = controllerObj;
        this.controlSocket = this.createSocket(ControlSocketId);
        this.apiServer = controllerObj.LStudent.policy.api_server;
        this.connectionParams = undefined; // Set when startConnection() is called
        this.getPublicKeyMessageRetryTimer = new GetPublicKeyMessageRetryTimer();
        this.joinMessageRetryTimer = new JoinMessageRetryTimer();
        pubsub_js_1.default.subscribe('onHeartbeatTimeout', (msg, data) => {
            this.onHeartbeatTimeout();
        });
        pubsub_js_1.default.subscribe('onTokenFailure', (msg, data) => {
            this.onTokenFailure();
        });
    }
    setDefaults() {
        this.classSocketDestination = SocketDestinationUndefined;
        this.classSocketUrl = '';
        this.classSocketTarget = '';
        this.currentClassData = undefined;
        this.targetedClassSocket = false;
        this.allowedIP = undefined; // TODO: Update this when network changes occur
        this.isInClass = false;
        this.controlSocketNeedsManualReconnect = false;
    }
    isUsingTargetedClassSocket() {
        return this.targetedClassSocket;
    }
    setUsingTargetedClassSocket(val) {
        this.targetedClassSocket = val;
    }
    getControlSocketConnectionState() {
        return this.controlSocket.connected;
    }
    setControlSocketNeedsManualReconnect(val) {
        this.controlSocketNeedsManualReconnect = val;
    }
    doesControlSocketNeedManualReconnect() {
        return this.controlSocketNeedsManualReconnect;
    }
    getSocketDestination() {
        return this.classSocketDestination;
    }
    setClassSocketDestination(room) {
        logger.logMessage('SocketController.setClassSocketDestination(): Setting destination to ' +
            room);
        this.classSocketDestination = room;
    }
    setInClass(val) {
        this.isInClass = val;
    }
    shouldBeInClass() {
        return this.isInClass;
    }
    lookup(obj) {
        logger.logMessage('SocketController.lookup(+)');
        obj.classSocketSupport = true;
        obj.clientVersion = this.sioParam.clientVersion;
        this.controlSocket.lookup(obj);
    }
    startConnection(connectionParams) {
        logger.logMessage('SocketController.startConnection(+)');
        this.connectionParams = connectionParams;
        this.controlSocket.startConnection(connectionParams);
    }
    postCurrentScreenMessage(obj) {
        logger.logMessage('SocketController.postCurrentScreenMessage(+)');
        if (this.classSocket) {
            this.classSocket.postCurrentScreenMessage(obj);
        }
        else {
            logger.logWarning('SocketController.postCurrentScreenMessage(): No class socket.');
        }
    }
    postShareStudentScreenResponse(shareStudentScreenData) {
        logger.logMessage('SocketController.postShareStudentScreenResponse(+)');
        if (this.classSocket) {
            this.classSocket.postShareStudentScreenResponse(shareStudentScreenData);
        }
        else {
            logger.logWarning('SocketController.postShareStudentScreenResponse(): No class socket.');
        }
    }
    postStopStudentScreenBroadcast(stopStudentScreenData) {
        logger.logMessage('SocketController.postStopStudentScreenBroadcast(+)');
        if (this.classSocket) {
            this.classSocket.postStopStudentScreenBroadcast(stopStudentScreenData);
        }
        else {
            logger.logWarning('SocketController.postStopStudentScreenBroadcast(): No class socket.');
        }
    }
    postChatMessage(chatObj) {
        logger.logMessage('SocketController.postChatMessage(+)');
        if (this.classSocket) {
            this.classSocket.postChatMessage(chatObj);
        }
        else {
            logger.logWarning('SocketController.postChatMessage(): No class socket.');
        }
    }
    postRaiseHand(raiseHandObj, emailAddr) {
        logger.logMessage('SocketController.postRaiseHand(+)');
        if (this.classSocket) {
            this.classSocket.postRaiseHand(raiseHandObj, emailAddr);
        }
        else {
            logger.logWarning('SocketController.postRaiseHand(): No class socket.');
        }
    }
    postTelemetryMessage(telemetryObj) {
        logger.logDebug('SocketController.postTelemetryMessage(+)');
        if (this.classSocket) {
            this.classSocket.postTelemetryMessage(telemetryObj);
        }
        else {
            logger.logWarning('SocketController.postTelemetryMessage(): No class socket.');
        }
    }
    postMessageFromFactory(messageFactory) {
        logger.logDebug('SocketController.postMessageFromFactory(+)');
        if (this.classSocket) {
            this.classSocket.postFromMessageFactory(messageFactory);
        }
        else {
            logger.logWarning('SocketController.postMessageFromFactory(): No class socket.');
        }
    }
    postIntellitaskAssesmentMessage(assessmentMessage) {
        logger.logDebug('SocketController.postIntellitaskAssesmentMessage(+)');
        if (this.classSocket) {
            this.classSocket.emitObject(assessmentMessage);
        }
        else {
            logger.logWarning('SocketController.postIntellitaskAssesmentMessage(): No class socket.');
        }
    }
    joinRoom(classData, agentVersion) {
        logger.logMessage('SocketController.joinRoom(+)');
        if (!classData || !classData.rooms) {
            logger.logError('SocketController.joinRoom(): Missing classData');
            return;
        }
        this.setUsingTargetedClassSocket(!!(classData &&
            classData.classSocketData &&
            classData.classSocketData.url &&
            classData.classSocketData.target));
        this.currentClassData = classData;
        if (this.isUsingTargetedClassSocket()) {
            logger.logMessage('SocketController.joinRoom(): Instantiating new class socket.');
            this.createClassSocketAndStartConnection(classData.classSocketData.url, classData.classSocketData.target);
        }
        else {
            logger.logMessage('SocketController.joinRoom(): No targeted class socket.');
            this.classSocket = this.controlSocket;
        }
        logger.logMessage('SocketController.joinRoom(): Joining student room ' +
            classData.rooms.studentRoom);
        this.setInClass(true);
        this.joinMessageRetryTimer.setCallback(() => {
            var _a;
            (_a = this.classSocket) === null || _a === void 0 ? void 0 : _a.joinRoom(classData.rooms.studentRoom, agentVersion);
        });
        this.getPublicKeyMessageRetryTimer.setCallback(() => {
            var _a;
            // This used to end up emitting a joinClass message repeatedly, however
            // this was determined to be extremely expensive on the backend
            // and this is an attempt to get the public key in a way that
            // produces less load on the backend
            (_a = this.classSocket) === null || _a === void 0 ? void 0 : _a.requestPublicKey(classData.rooms.studentRoom);
        });
        if (!this.isUsingTargetedClassSocket() &&
            //@ts-ignore
            this.controlSocket.connected == defs_1.ConnectionStateEnum.Connected) {
            logger.logMessage('SocketController.joinRoom(): Publishing onJoinClassPostProcess');
            pubsub_js_1.default.publish('onJoinClassPostProcess', this.currentClassData);
        }
    }
    leaveRoom(obj) {
        logger.logMessage('SocketController.leaveRoom(+)');
        this.setInClass(false);
        if (this.classSocket) {
            logger.logMessage('SocketController.leaveRoom(): Issuing leave on socket ID ' +
                this.classSocket.getIdForController());
            this.classSocket.leaveRoom(obj);
            this.disposeSocket(this.classSocket);
        }
        this.classSocketUrl = '';
        this.classSocketTarget = '';
        this.currentClassData = undefined;
    }
    disposeSocket(socket) {
        logger.logMessage('SocketController.disposeSocket(+)');
        if (socket && socket.getIdForController() === ClassSocketId) {
            socket.destroy();
        }
        else {
            logger.logMessage('SocketController.disposeSocket(): Not disposing.');
        }
    }
    shouldClassSocketBeConnected() {
        if (!this.isUsingTargetedClassSocket())
            return true;
        return this.shouldBeInClass();
    }
    createSocket(id) {
        const controllerObj = this.sioParam;
        controllerObj.controller = this;
        controllerObj.idForController = id;
        return new internal_1.SocketIOMsg(controllerObj);
    }
    createClassSocketAndStartConnection(url, target) {
        this.classSocketUrl = url;
        this.classSocketTarget = target;
        logger.logMessage('SocketController.createClassSocketAndStartConnection(): Creating targeted class socket.');
        this.classSocket = this.createSocket(ClassSocketId);
        logger.logMessage('SocketController.createClassSocketAndStartConnection(): connectionParams = ' +
            JSON.stringify(this.connectionParams));
        if (this.connectionParams)
            this.classSocket.startConnection(this.connectionParams);
    }
    shouldRetrySocketConnection(id) {
        logger.logDebug('SocketController.shouldRetrySocketConnection(' +
            id +
            '), targetedClassSocket = ' +
            this.isUsingTargetedClassSocket());
        if (id === ClassSocketId) {
            if (
            //@ts-ignore
            this.controlSocket.connected === defs_1.ConnectionStateEnum.Connected) {
                let c = this.shouldClassSocketBeConnected();
                logger.logMessage('SocketController.shouldRetrySocketConnection(): shouldClassSocketBeConnected returned ' +
                    c);
                return c;
            }
            else {
                logger.logMessage('SocketController.shouldRetrySocketConnection(): returning false');
                return false;
            }
        }
        logger.logDebug('SocketController.shouldRetrySocketConnection(): returning true');
        return true;
    }
    onSocketReconnect(sio) {
        if (!sio) {
            logger.logError('SocketController.onSocketReconnect(): Missing sio parameter.');
            return;
        }
        logger.logMessage('SocketController.onSocketReconnect(+)');
    }
    // Returns true if we need to attempt a reconnect manually.
    // Returns false if we should not.
    onSocketDisconnect(sio, reason) {
        if (!sio) {
            logger.logError('SocketController.onSocketDisconnect(): Missing sio parameter.');
            return false;
        }
        logger.logMessage('SocketController.onSocketDisconnect(' +
            sio.getIdForController() +
            '), reason = ' +
            reason);
        if (sio.getIdForController() === ControlSocketId) {
            sio.setConnectedState(defs_1.ConnectionStateEnum.Disconnected);
            sio.publishConnectionChange();
            if (this.doesControlSocketNeedManualReconnect()) {
                return true;
            }
            if (reason === 'io server disconnect') {
                //|| reason === 'transport close') {
                if (this.classSocket && this.isUsingTargetedClassSocket())
                    this.classSocket.disconnect(true);
                return true;
            }
        }
        return false;
    }
    onHeartbeatTimeout() {
        var _a;
        this.setDefaults();
        this.setControlSocketNeedsManualReconnect(true);
        this.controlSocket.disconnect();
        if (this.isUsingTargetedClassSocket()) {
            (_a = this.classSocket) === null || _a === void 0 ? void 0 : _a.disconnect(true);
        }
    }
    onTokenFailure() {
        var _a;
        this.setDefaults();
        this.setControlSocketNeedsManualReconnect(true);
        this.controlSocket.disconnect();
        if (this.isUsingTargetedClassSocket()) {
            (_a = this.classSocket) === null || _a === void 0 ? void 0 : _a.disconnect(true);
        }
    }
    onSocketAuthError(sio, obj) {
        var _a;
        if (!sio) {
            logger.logError('SocketController.onSocketAuthError(): Missing sio parameter.');
            return false;
        }
        if (sio.getIdForController() === ClassSocketId &&
            this.isUsingTargetedClassSocket()) {
            this.setDefaults();
            this.setControlSocketNeedsManualReconnect(true);
            this.controlSocket.disconnect();
            (_a = this.classSocket) === null || _a === void 0 ? void 0 : _a.disconnect(true);
        }
        else {
            pubsub_js_1.default.publish('onTokenStatus', {
                validToken: false,
                error: sio.formAuthError(JSON.stringify(obj))
            });
            sio.onTokenError(obj.status, sio.getRetryConnectionParams());
        }
        return true;
    }
    onSocketAuthenticated(sio, authenticated) {
        if (!sio) {
            logger.logError('SocketController.onSocketAuthenticated(): Missing sio parameter.');
            return;
        }
        if (authenticated) {
            sio.setConnectedState(defs_1.ConnectionStateEnum.Connected);
            sio.postMessage(); // Flush any queued messages
            sio.publishConnectionChange();
            if (sio.getIdForController() == ClassSocketId &&
                this.isUsingTargetedClassSocket() &&
                this.shouldBeInClass()) {
                logger.logMessage('SocketController.onSocketAuthenticated(): Publishing onJoinClassPostProcess');
                pubsub_js_1.default.publish('onJoinClassPostProcess', this.currentClassData);
            }
        }
    }
    onSocketConnectError(sio, data) {
        if (!sio) {
            logger.logError('SocketController.onSocketConnectError(): Missing sio parameter.');
            return;
        }
        if (data) {
            sio.setConnectedState(defs_1.ConnectionStateEnum.Disconnected);
            sio.publishConnectionChange();
        }
    }
    publishConnectionChange(id, obj) {
        logger.logMessage('SocketController.publishConnectionChange(' + id + ')');
        if (id === ControlSocketId) {
            logger.logMessage('SocketController.publishConnectionChange(): Publishing connection state change: ' +
                JSON.stringify(obj));
            pubsub_js_1.default.publish('onConnectionStateChange', obj);
            internal_1.chrome.runtime.sendMessage({
                message: 'ConnectionStateChange',
                data: obj
            });
        }
    }
    isMessageAllowedFromThisSocket(socketId, socketMsg) {
        if (!this.isUsingTargetedClassSocket())
            return true;
        if (['joinClass', 'leaveClass'].includes(socketMsg.type) &&
            socketId !== ControlSocketId) {
            return false;
        }
        // if (socketMsg.type === 'joinClass' && id !== ControlSocketId)
        //     return false;
        // if (socketMsg.type === 'leaveClass' && id !== ControlSocketId)
        //     return false;
        return true;
    }
    processSocketMessage(socketId, socketMsg) {
        return new Promise(async (resolve, reject) => {
            if (!socketMsg.hasOwnProperty('type')) {
                resolve(socketMsg);
                return;
            }
            if (!this.isMessageAllowedFromThisSocket(socketId, socketMsg)) {
                logger.logMessage("SocketController.processSocketMessage(): message '" +
                    socketMsg.type +
                    "' passed by id '" +
                    socketId +
                    "' cannot be processed.");
                reject();
                return;
            }
            logger.logMessage('SocketController.processSocketMessage(): Processing: ' +
                JSON.stringify(socketMsg));
            if (socketMsg.type === 'joinClass') {
                this.getPublicKeyMessageRetryTimer.reset();
                this.joinMessageRetryTimer.reset();
                this.setUsingTargetedClassSocket(!!(socketMsg &&
                    socketMsg.joinClassMessage &&
                    socketMsg.joinClassMessage.classSocketData &&
                    socketMsg.joinClassMessage.classSocketData.url &&
                    socketMsg.joinClassMessage.classSocketData.target));
            }
            else if (socketMsg.type === 'leaveClass') {
                if (this.leaveClassCallback) {
                    await this.leaveClassCallback();
                }
            }
            resolve(socketMsg);
        });
    }
    isIPAllowed(socketId, orgId) {
        return new Promise((resolve, reject) => {
            if (socketId === ControlSocketId ||
                !this.isUsingTargetedClassSocket() ||
                this.allowedIP === undefined) {
                internal_1.IPAddressBlocking.checkIP(this.apiServer, orgId).then((allowedIP) => {
                    this.allowedIP = allowedIP;
                    allowedIP ? resolve(true) : reject();
                });
            }
            else if (socketId === ClassSocketId) {
                this.allowedIP ? resolve(true) : reject();
            }
        });
    }
    retrieveSocketServer(id, accessToken) {
        return new Promise((resolve, reject) => {
            if (id === ControlSocketId || !this.isUsingTargetedClassSocket()) {
                internal_1.SocketEndpoint.retrieveSocketServer(this.apiServer, accessToken)
                    .then((socketUrl) => {
                    resolve(socketUrl);
                })
                    .catch((err) => {
                    reject(err);
                });
            }
            else if (id === ClassSocketId) {
                resolve({
                    socketServerEndpoint: this.classSocketUrl
                });
            }
        });
    }
    getConnectHeaders(deviceName) {
        return new Promise((resolve) => {
            var _a, _b;
            const deviceId = internal_1.UserInfoRetriever.getDeviceID();
            const socketTarget = this.classSocketTarget;
            const lsairClientVersionString = this.sioParam.socketAgentHeader;
            let hasHeaders = false;
            const headersObj = {
                transportOptions: {
                    polling: {
                        extraHeaders: {}
                    }
                },
                transports: (_b = (_a = this.connectionParams) === null || _a === void 0 ? void 0 : _a.socketTransportOpts) !== null && _b !== void 0 ? _b : [
                    'polling',
                    'websocket'
                ]
            };
            if (deviceId && deviceId.length > 0) {
                headersObj.transportOptions.polling.extraHeaders['device-id'] =
                    deviceId;
                hasHeaders = true;
            }
            if (socketTarget && socketTarget.length > 0) {
                headersObj.transportOptions.polling.extraHeaders['target'] =
                    socketTarget;
                hasHeaders = true;
            }
            if (lsairClientVersionString) {
                headersObj.transportOptions.polling.extraHeaders['X-LSA-Agent'] =
                    lsairClientVersionString;
                hasHeaders = true;
            }
            if (hasHeaders) {
                resolve(headersObj);
            }
            else {
                resolve(false);
            }
        });
    }
    restartAgent() {
        internal_1.chrome.runtime.reload();
    }
    setLeaveClassCallback(callback) {
        this.leaveClassCallback = callback;
    }
}
exports.SocketController = SocketController;
class JoinMessageRetryTimer {
    constructor() {
        this.executionsLeft = JoinMessageResponseRetryMax;
        pubsub_js_1.default.subscribe('onSocketMessageEmitted', (msg, data) => {
            if (data &&
                data.event === 'fromClient' &&
                data.payloadType === 'join') {
                logger.logMessage('JoinMessageRetryTimer.onSocketMessageEmitted: "join" message has been emitted');
                this.waitTimer = setTimeout(this.execute.bind(this), JoinMessageResponseTimeout);
            }
        });
        pubsub_js_1.default.subscribe('onTelemetryRequest', (msg, data) => {
            logger.logMessage('JoinMessageRetryTimer.onTelemetryRequest: got a telemetry request, stopping.');
            this.reset();
        });
    }
    execute() {
        if (this.executionsLeft > 0) {
            logger.logMessage('JoinMessageRetryTimer.execute(): Executing callback. Executions remaining: ' +
                this.executionsLeft);
            if (this.cb)
                this.cb();
            this.executionsLeft--;
        }
        else {
            logger.logWarning('JoinMessageRetryTimer.execute(): Ran out of executions.');
            if (this.waitTimer) {
                clearTimeout(this.waitTimer);
                this.waitTimer = null;
            }
        }
    }
    setCallback(callback) {
        logger.logInfo('JoinMessageRetryTimer.setCallback(): called.');
        this.cb = callback;
        this.execute();
    }
    reset() {
        logger.logDebug('JoinMessageRetryTimer.reset(+)');
        if (this.waitTimer) {
            logger.logMessage('JoinMessageRetryTimer.reset(): Cancelling timer.');
            clearTimeout(this.waitTimer);
            this.waitTimer = null;
        }
        this.executionsLeft = JoinMessageResponseRetryMax;
    }
}
exports.JoinMessageRetryTimer = JoinMessageRetryTimer;
//# sourceMappingURL=socketController.js.map