"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.FullScreenActivityDirector = void 0;
const lsaClient_1 = require("./lsaClient");
/**
 * Activities that can become full-screen can implement an interface to be directed by this class. Its purpose
 * is to set the activity to full screen based on its priority. The business determines the most important
 * window to be full screen and assigns the priority. The main use case is for the blank screen
 * desktop limiter and the full screen show teacher. This class will activate or de-activate full screen
 * based on who should be top-most.
 */
class FullScreenActivityDirector {
    constructor() {
        this.activities = new Map();
        // Create queues to handle the starting/stopping of the full screen activities.
        // We can get into a state where the client may also use this class but could queue
        // full screen activities at the same time they're already being processed. This can
        // cause fighting between activities, where both are trying to be full screen at the
        // same time. Therefore, we'll use queues to process them synchronously.
        this.activityQueueElementArray = [];
        this.removalQueueElementArray = [];
        this.processingActivityQueue = false;
        this.processingRemovalQueue = false;
    }
    get highestPriority() {
        const lsaClient = lsaClient_1.LSAClient.getInstance();
        lsaClient.logger.logInfo('FullScreenActivityDirector.highestPriority(): activities => ' + this.activities.size);
        let highest = -1;
        for (const [k] of this.activities) {
            lsaClient.logger.logInfo('FullScreenActivityDirector.highestPriority(): k => ' + k);
            if (k > highest) {
                highest = k;
            }
        }
        return highest;
    }
    static getInstance() {
        if (!FullScreenActivityDirector.instance) {
            FullScreenActivityDirector.instance = new FullScreenActivityDirector();
        }
        return FullScreenActivityDirector.instance;
    }
    async clear() {
        for (const [k, v] of this.activities) {
            await v.activity.stopFullScreenActivity(v.parameters);
        }
        this.activities.clear();
    }
    async queueActivity(priority, toQueue, parameters) {
        lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.queueActivity(+): priority = ${priority}`);
        this.activityQueueElementArray.push({
            priority,
            toQueue,
            parameters
        });
        if (this.processingActivityQueue === true) {
            // TODO: Return when this activity's actual setup is complete, rather than just returning.
            // It does prevent us from getting window infighting, but would be better if the caller knew
            // setup was actually complete before moving on.
            lsaClient_1.LSAClient.getInstance().logger.logDebug('FullScreenActivityDirector.queueActivity(): Queue already being processed.');
            return;
        }
        this.processingActivityQueue = true;
        try {
            while (this.activityQueueElementArray.length > 0) {
                lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.queueActivity(): Queue length = ${this.activityQueueElementArray.length}`);
                const element = this.activityQueueElementArray.shift();
                if (element) {
                    lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.queueActivity(): Processing element ${element.priority}`);
                    await this.queueActivity_queueElement(element.priority, element.toQueue, element.parameters);
                    lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.queueActivity(): Completed processing element ${element.priority}`);
                }
            }
        }
        finally {
            this.processingActivityQueue = false;
        }
    }
    async queueActivity_queueElement(priority, toQueue, parameters) {
        var _a;
        const lsaClient = lsaClient_1.LSAClient.getInstance();
        let callStarter = true;
        if (priority <= 0) {
            throw new Error('FullScreenActivityDirector.queueActivity_queueElement(): Priority must be a positive number.');
        }
        if (this.activities.has(priority)) {
            // If the parameters have changed between the last time it was queued and now,
            // set them to the new value.
            const oldParameters = JSON.stringify((_a = this.activities.get(priority)) === null || _a === void 0 ? void 0 : _a.parameters);
            const newParameters = JSON.stringify(parameters);
            lsaClient.logger.logInfo('FullScreenActivityDirector.queueActivity_queueElement(): oldParameters => ' + oldParameters);
            lsaClient.logger.logInfo('FullScreenActivityDirector.queueActivity_queueElement(): newParameters => ' + newParameters);
            lsaClient.logger.logInfo('FullScreenActivityDirector.queueActivity_queueElement(): highestPriority => ' + this.highestPriority);
            if (oldParameters !== newParameters) {
                // Parameters have changed. If this activity is already the highest priority, 
                // we want to stop it and let the last part of this function start us back up
                // again with our new parameters.
                if (this.highestPriority === priority) {
                    const a = this.activities.get(priority);
                    await (a === null || a === void 0 ? void 0 : a.activity.stopFullScreenActivity(a.parameters));
                }
                this.activities.set(priority, {
                    activity: toQueue,
                    parameters: parameters
                });
            }
            else {
                // If the parameters haven't changed, don't call the start again.
                callStarter = false;
            }
        }
        else {
            // Add this instance to the map
            // The same parameters will be used for both starting and stopping
            this.activities.set(priority, {
                activity: toQueue,
                parameters: parameters
            });
        }
        // Any activities with lower priority will be stopped.
        // If this activity is lower, then it won't be started now but it
        // will be started when a higher priority activity removes themselves
        // from the queue.
        if (this.highestPriority !== priority || !callStarter) {
            return;
        }
        lsaClient.logger.logInfo('FullScreenActivityDirector.queueActivity_queueElement(): activities => ' + JSON.stringify(this.activities));
        lsaClient.logger.logInfo('FullScreenActivityDirector.queueActivity_queueElement(): priority => ' + priority);
        for (const [k, v] of this.activities) {
            if (k < priority) {
                await v.activity.stopFullScreenActivity(v.parameters);
            }
        }
        await toQueue.startFullScreenActivity(parameters);
    }
    async removeActivity(toRemove) {
        lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.removeActivity(+): toRemove = ${toRemove}`);
        this.removalQueueElementArray.push(toRemove);
        if (this.processingRemovalQueue === true) {
            // TODO: Return when this activity's actual teardown is complete, rather than just returning.
            // It does prevent us from getting window infighting, but would be better if the caller knew
            // teardown was actually complete before moving on.
            lsaClient_1.LSAClient.getInstance().logger.logDebug('FullScreenActivityDirector.removeActivity(): Queue already being processed.');
            return;
        }
        this.processingRemovalQueue = true;
        try {
            while (this.removalQueueElementArray.length > 0) {
                lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.removeActivity(): Queue length = ${this.removalQueueElementArray.length}`);
                const element = this.removalQueueElementArray.shift();
                if (element) {
                    lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.removeActivity(): Processing element ${toRemove}`);
                    await this.removeActivity_queueElement(toRemove);
                    lsaClient_1.LSAClient.getInstance().logger.logDebug(`FullScreenActivityDirector.removeActivity(): Completed processing element ${toRemove}`);
                }
            }
        }
        finally {
            this.processingRemovalQueue = false;
        }
    }
    async removeActivity_queueElement(toRemove) {
        // If I'm the top priority, stop me
        if (this.highestPriority === toRemove) {
            const a = this.activities.get(toRemove);
            await (a === null || a === void 0 ? void 0 : a.activity.stopFullScreenActivity(a.parameters));
            // remove me
            this.activities.delete(toRemove);
            // Find the next priority down and start it
            const h = this.highestPriority;
            if (h > 0) {
                const next = this.activities.get(h);
                await (next === null || next === void 0 ? void 0 : next.activity.startFullScreenActivity(next.parameters));
            }
        }
        else {
            // I'm not running so just remove me
            this.activities.delete(toRemove);
        }
    }
}
exports.FullScreenActivityDirector = FullScreenActivityDirector;
//# sourceMappingURL=fullScreenActivityDirector.js.map