"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommonWindow = void 0;
const loggerInterop_1 = require("../js/interop/loggerInterop");
const internal_1 = require("../internal");
class CommonWindow {
    constructor() {
        this._logger = new loggerInterop_1.LoggerInterop();
    }
    hasBoundWindow() {
        return this.w !== null;
    }
    show() {
        var _a;
        (_a = this.w) === null || _a === void 0 ? void 0 : _a.show();
    }
    hide() {
        var _a;
        (_a = this.w) === null || _a === void 0 ? void 0 : _a.hide();
    }
    focus() {
        var _a;
        (_a = this.w) === null || _a === void 0 ? void 0 : _a.focus();
    }
    isMinimized() {
        if (!this.w) {
            throw new Error('CommonWindow.isMinimized(): No binding window.');
        }
        return this.w.isMinimized();
    }
    isMaximized() {
        if (!this.w) {
            throw new Error('CommonWindow.isMaximized(): No binding window.');
        }
        return this.w.isMaximized();
    }
    getBoundCoordinate(position, screenDimension, windowDimension, coordinate = 0) {
        if (!position) {
            return coordinate;
        }
        switch (position) {
            case 'center':
                coordinate = Math.round(screenDimension / 2 - windowDimension / 2);
                break;
            case 'left':
            case 'top':
                coordinate = 100;
                break;
            case 'right':
            case 'bottom':
                coordinate = Math.round(screenDimension - windowDimension - 60);
                break;
        }
        return coordinate;
    }
    ;
    minimize() {
        if (!this.w) {
            throw new Error('CommonWindow.minimize: No binding window.');
        }
        return new Promise((resolve) => {
            if (!this.w.isMinimized()) {
                this._logger.logDebug('CommonWindow.minimize: Executing minimize.');
                this.handleEvent('minimized', () => {
                    this._logger.logDebug('CommonWindow.minimize(): minimized event fired');
                    resolve(true);
                });
                this.w.minimize();
            }
            else {
                this._logger.logDebug('CommonWindow.minimize(): already minimized');
                resolve(false);
            }
        });
    }
    maximize() {
        var _a;
        (_a = this.w) === null || _a === void 0 ? void 0 : _a.maximize();
    }
    restore() {
        var _a;
        // Note: this works differently on Electron and Chrome. in electron it will only restore from a minimized state. In Chrome, it will also unmaximize
        (_a = this.w) === null || _a === void 0 ? void 0 : _a.restore();
    }
    handleEvent(eventName, fnc) {
        if (internal_1.Utils.isElectron()) {
            const that = this;
            this.w.on(eventName, function oneTimeOnly() {
                fnc();
                that.w.off(eventName, oneTimeOnly);
            });
        }
        else {
            const eventFnc = 'on' + eventName.charAt(0).toUpperCase() + eventName.slice(1);
            const that = this;
            this.w[eventFnc].addListener(function oneTimeOnly() {
                fnc();
                that.w[eventFnc].removeListener(oneTimeOnly);
            });
        }
    }
}
exports.CommonWindow = CommonWindow;
//# sourceMappingURL=commonWindow.js.map