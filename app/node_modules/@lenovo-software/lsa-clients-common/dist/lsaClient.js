"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.LSAClient = void 0;
const pubsub_js_1 = __importDefault(require("pubsub-js"));
const internal_1 = require("./internal");
const defs_1 = require("./js/defs");
class ClientTelemetryInstrumentationImplementations {
  constructor() {
    this.screenCapture = new internal_1.DefaultThumbnail();
    this.browserInstrumentation = null;
    this.batteryInstrumentation = null;
    this.runningAppInstrumentation = null;
    this.lsaClientTelemetry = internal_1.TelemetryInterop.getInstance();
  }
}
class ClientChat {
  postChatMessageToTeacher(msg) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var newMsg = new internal_1.OutgoingSocketChatMessage();
    newMsg.message = msg.message;
    newMsg.timestamp = msg.timestamp;
    newMsg.activeClassID =
      (_b =
        (_a = LSAClient.getInstance().getClassChannel()) === null ||
        _a === void 0
          ? void 0
          : _a.getActiveClassID()) !== null && _b !== void 0
        ? _b
        : "";
    newMsg.className =
      (_d =
        (_c = LSAClient.getInstance().getClassChannel()) === null ||
        _c === void 0
          ? void 0
          : _c.getClassName()) !== null && _d !== void 0
        ? _d
        : "";
    newMsg.chatHistoryEnabled =
      (_f =
        (_e = LSAClient.getInstance().getClassChannel()) === null ||
        _e === void 0
          ? void 0
          : _e.getChatHistoryEnabled()) !== null && _f !== void 0
        ? _f
        : false;
    newMsg.classID =
      (_h =
        (_g = LSAClient.getInstance().getClassChannel()) === null ||
        _g === void 0
          ? void 0
          : _g.getClassID()) !== null && _h !== void 0
        ? _h
        : "";
    newMsg.loginName = LSAClient.getInstance().storage.loadLoginName();
    newMsg.studentFullName = LSAClient.getInstance().storage.loadDisplayName();
    LSAClient.getInstance().socketController.postChatMessageToTeacher(newMsg);
  }
  postRaiseHandStatusToTeacher(status) {
    LSAClient.getInstance().socketController.postRaiseHandStatusToTeacher(
      status
    );
  }
}
class ClassroomEventRequestResponse {
  postCurrentScreen(response) {
    LSAClient.getInstance().socketController.postCurrentScreenMessage(response);
  }
}
class StudentScreenShare {
  constructor() {
    /**
     * NOTE:
     * stores the id of teacher that originated the screen share
     * to be sent in socket messages from student to teacher
     * so that only co-teachers respond to start & end view broadcast
     * not the teacher that originated screen share
     */
    this.teacherOriginator = "";
    this.lsaClient = LSAClient.getInstance();
  }
  setTeacherOriginator(teacherOriginator) {
    this.teacherOriginator = teacherOriginator;
  }
  onAcceptStudentScreenShare() {
    pubsub_js_1.default.publish("onAcceptStudentScreenShare");
  }
  onStopStudentScreenShare() {
    pubsub_js_1.default.publish("onStopStudentScreenShare");
  }
  postShareStudentScreenResponse(data) {
    if (this.teacherOriginator.length === 0) {
      this.lsaClient.logger.logError(
        "StudentScreenShare.postShareStudentScreenResponse: teacherOriginator is empty."
      );
      return;
    }
    data = Object.assign(Object.assign({}, data), {
      teacherOriginator: this.teacherOriginator,
    });
    this.lsaClient.socketController.postShareStudentScreenResponse(data);
  }
  postStopStudentScreenBroadcast() {
    if (this.teacherOriginator.length === 0) {
      this.lsaClient.logger.logError(
        "StudentScreenShare.postStopStudentScreenBroadcast: teacherOriginator is empty."
      );
      return;
    }
    const data = { teacherOriginator: this.teacherOriginator };
    this.lsaClient.socketController.postStopStudentScreenBroadcast(data);
  }
}
class ConferenceUIMessageSink {
  onConferenceParamsSet() {
    var _a;
    (_a = LSAClient.getInstance().conferenceController) === null ||
    _a === void 0
      ? void 0
      : _a.onConferenceParamsSet();
  }
  onConferenceError(data) {
    internal_1.chromeMessenger.executeListeners({
      message: "FromUI_ConferenceError",
    });
  }
  onConferenceAttachComplete() {
    internal_1.chromeMessenger.executeListeners({
      message: "FromUI_ConferenceAttachComplete",
    });
  }
  onConferenceDetachComplete() {
    internal_1.chromeMessenger.executeListeners({
      message: "FromUI_ConferenceDetachComplete",
    });
  }
  onConferenceAttendeeId(data) {
    internal_1.chromeMessenger.executeListeners({
      message: "FromUI_ConferenceAttendeeId",
      data: {
        attendeeId: data === null || data === void 0 ? void 0 : data.attendeeId,
      },
    });
  }
  onConferenceWindowClosed() {
    pubsub_js_1.default.publish("onUnexpectedConferenceWindowClose");
  }
}
class MeetingUIMessageSink {
  onMeetingEnded() {
    pubsub_js_1.default.publish("onMeetingEnded");
  }
  onChatWindowOpen() {
    pubsub_js_1.default.publish("onChatWindowOpen");
  }
  onUnexpectedChatWindowClose() {
    pubsub_js_1.default.publish("onUnexpectedChatWindowClose");
  }
}
class MonitoringWindowSink {
  userAllowsMonitoring() {
    internal_1.chromeMessenger.executeListeners({
      message: "UserAllowsMonitoring",
    });
  }
  userRejectsMonitoring() {
    internal_1.chromeMessenger.executeListeners({
      message: "UserRejectsMonitoring",
    });
  }
  setMonitoringWindowState(state) {
    internal_1.chromeMessenger.executeListeners({
      message: "MonitoringWindowState",
      stateObj: {
        presentation: state.presentation,
        param: state.param,
      },
    });
  }
  getMonitoringWindowState() {
    return new Promise((resolve, reject) => {
      internal_1.chromeMessenger.executeListeners(
        {
          message: "RequestMonitoringWindowState",
        },
        null,
        (lastMonitoringStateObj) => {
          resolve(lastMonitoringStateObj);
        }
      );
    });
  }
}
class BlankScreenConfigurationController {
  getShouldBlockInputDuringBlankScreen() {
    var _a;
    let result = !((_a = internal_1.OptInParametersStore.getInstance()) ===
      null || _a === void 0
      ? void 0
      : _a.getRequireDeviceMonitoringOptIn());
    return result;
  }
}
class LSAClient {
  constructor() {
    this.isInitialized = false;
    this.storage = new internal_1.DefaultStorage();
    this.clientLimiting = null;
    this.conferenceDirectiveHandler = null;
    this.conferenceController = null;
    this.meetingDirectiveHandler = null;
    this.meetingController = null;
    this.statusLight = null;
    this.statusControllerInterop = null;
    this._eventSubscribers = null;
    this._telemetryInstrumentation = null;
    this._logger = null;
    this._networkCallback = null;
    this._orgChecker = null;
    this._networkTransportOpts = null;
    this._cryptoSubtle = null;
    this._logExporter = null;
    this._runtime = null;
    this._knownClientStatus = null;
    this._reprovisionActionHandler = null;
    this._routableWindowFactory = null;
    this._screenInfo = null;
    this._webHistory = null;
    this.otmBrowserInstrumentation = null;
    // Classroom workers
    this._classChannel = null;
    this.limitingRequestHandler = null;
    this.studentScreenShareController = null;
    this.unverifiedOrgOption = null;
    this.contextMenu = null;
    // UI callback interfaces
    this._clientChat = null;
    this._conferenceUIMessageSink = null;
    this._meetingUIMessageSink = null;
    this._monitoringWindowSink = new MonitoringWindowSink();
    this._classroomEventRequestResponse = null;
    this._studentScreenShare = null;
    this._blankScreenConfigurationController = null;
  }
  static getInstance() {
    if (!LSAClient.instance) {
      LSAClient.instance = new LSAClient();
    }
    return LSAClient.instance;
  }
  // This method should not get called by production code. It is only here to
  // remove instances created by unit tests (if such removal is needed.)
  static destroyInstance() {
    if (LSAClient.instance) {
      //@ts-ignore
      LSAClient.instance = null;
    }
  }
  // Client interfaces
  get logger() {
    if (!this._logger) {
      this._logger = new internal_1.DefaultLogger();
    }
    return this._logger;
  }
  set logger(logger) {
    this._logger = logger;
  }
  get clientParams() {
    if (!this._params) {
      this._params = new internal_1.LSAClientParams(this.storage);
    }
    return this._params;
  }
  get networkCallback() {
    if (!this._networkCallback) {
      this._networkCallback = new internal_1.DefaultNetworkCallback();
    }
    return this._networkCallback;
  }
  set networkCallback(cb) {
    this._networkCallback = cb;
  }
  get cryptoSubtleCallback() {
    if (!this._cryptoSubtle) {
      this._cryptoSubtle = new internal_1.DefaultCryptoSubtle();
    }
    return this._cryptoSubtle;
  }
  set cryptoSubtleCallback(cb) {
    this._cryptoSubtle = cb;
  }
  get orgChecker() {
    if (!this._orgChecker) {
      this._orgChecker = new internal_1.DefaultOrgCheck();
    }
    return this._orgChecker;
  }
  set orgChecker(cb) {
    this._orgChecker = cb;
  }
  get networkTransportOpts() {
    if (!this._networkTransportOpts) {
      this._networkTransportOpts = new internal_1.DefaultNetworkTransportOpts();
    }
    return this._networkTransportOpts;
  }
  set networkTransportOpts(cb) {
    this._networkTransportOpts = cb;
  }
  get socketController() {
    if (!this._socketController) {
      this._socketController = new internal_1.SocketControllerInterop();
    }
    return this._socketController;
  }
  get logExporter() {
    if (!this._logExporter) {
      this._logExporter = internal_1.LogExporter.getInstance();
    }
    return this._logExporter;
  }
  get runtime() {
    if (!this._runtime) {
      this._runtime = new internal_1.DefaultRuntime();
    }
    return this._runtime;
  }
  set runtime(r) {
    this._runtime = r;
  }
  set knownClientStatus(kcs) {
    this._knownClientStatus = kcs;
  }
  set reprovisionActionHandler(rah) {
    this._reprovisionActionHandler = rah;
  }
  get routableWindowFactory() {
    return this._routableWindowFactory;
  }
  set routableWindowFactory(win) {
    this._routableWindowFactory = win;
  }
  get screenInfo() {
    return this._screenInfo;
  }
  set screenInfo(si) {
    this._screenInfo = si;
  }
  // Client callbacks
  get telemetryInstrumentation() {
    if (!this._telemetryInstrumentation) {
      this._telemetryInstrumentation =
        new ClientTelemetryInstrumentationImplementations();
    }
    return this._telemetryInstrumentation;
  }
  get eventSubscribers() {
    if (!this._eventSubscribers) {
      this._eventSubscribers = new internal_1.EventSubscribers();
    }
    return this._eventSubscribers;
  }
  get clientChat() {
    if (!this._clientChat) {
      this._clientChat = new ClientChat();
    }
    return this._clientChat;
  }
  get classroomEventRequestResponse() {
    if (!this._classroomEventRequestResponse) {
      this._classroomEventRequestResponse = new ClassroomEventRequestResponse();
    }
    return this._classroomEventRequestResponse;
  }
  get studentScreenShare() {
    if (!this._studentScreenShare) {
      this._studentScreenShare = new StudentScreenShare();
    }
    return this._studentScreenShare;
  }
  get conferenceUIMessageSink() {
    if (!this._conferenceUIMessageSink) {
      this._conferenceUIMessageSink = new ConferenceUIMessageSink();
    }
    return this._conferenceUIMessageSink;
  }
  get meetingUIMessageSink() {
    if (!this._meetingUIMessageSink) {
      this._meetingUIMessageSink = new MeetingUIMessageSink();
    }
    return this._meetingUIMessageSink;
  }
  get monitoringWindowSink() {
    return this._monitoringWindowSink;
  }
  get blankScreenConfigurationController() {
    if (!this._blankScreenConfigurationController) {
      this._blankScreenConfigurationController =
        new BlankScreenConfigurationController();
    }
    return this._blankScreenConfigurationController;
  }
  getStatusLightImpl() {
    return this.statusLight;
  }
  get webHistory() {
    if (!this._webHistory) {
      this._webHistory = new internal_1.WebHistory(
        this.storage,
        this.socketController,
        this._classChannel || undefined
      );
    }
    return this._webHistory;
  }
  async leaveClass() {
    var _a;
    if (!this.isInitialized) {
      const errStr = "LSAClient.leaveClass(): Call .init(IStorage) first.";
      this.logger.logError(errStr);
      throw new Error(errStr);
    }
    // TODO: Handle null and handle if no current class
    (_a = this._classChannel) === null || _a === void 0
      ? void 0
      : _a.leaveCurrentClass();
  }
  getClassName() {
    var _a, _b;
    return (_b =
      (_a = this._classChannel) === null || _a === void 0
        ? void 0
        : _a.getClassName()) !== null && _b !== void 0
      ? _b
      : "";
  }
  getClassChannel() {
    var _a;
    return (_a = this._classChannel) !== null && _a !== void 0 ? _a : null;
  }
  getAgentVersionHeaderString() {
    var _a;
    let agentVersion = "";
    try {
      agentVersion =
        (_a = this.storage.getClientVersion()) !== null && _a !== void 0
          ? _a
          : "Unknown";
    } catch (err) {
      this.logger.logError("getAgentVersionHeaderString exception: " + err);
    }
    if (agentVersion.length === 0) {
      agentVersion = "Unknown";
    }
    return "LSAirClient/" + agentVersion;
  }
  onDeviceOnlineStatusChanged(connected) {
    if (connected) {
      this.logger.logInfo("onDeviceOnlineStatusChanged: device now online");
      // Do nothing - we are always trying to reconnect.
    } else {
      this.logger.logInfo("onDeviceOnlineStatusChanged: device now OFFLINE");
      pubsub_js_1.default.publish("onHeartbeatTimeout", 0);
    }
  }
  async init(storage, localeHandler = null) {
    // init i18n module
    if (localeHandler) {
      let langCode = localeHandler.getLocale();
      // if lang code received is not supported then default to English
      if (!internal_1.i18nCommonConfig.languages.includes(langCode)) {
        langCode = internal_1.i18nCommonConfig.fallbackLng;
      }
      await internal_1.i18nController.init(langCode);
    }
    return new Promise((resolve, reject) => {
      if (this.isInitialized) {
        resolve();
        return;
      }
      pubsub_js_1.default.subscribe("onConnectionStateChange", (msg, data) => {
        var _a, _b;
        this.logger.logMessage(
          "Received onConnectionStateChange - data: " + JSON.stringify(data)
        );
        if (data.connected === defs_1.ConnectionStateEnum.Connected) {
          this.socketController.doClassLookup();
        } else if (data.connected === defs_1.ConnectionStateEnum.Disconnected) {
          // Sends UI_SetState with blank classID, studentRoom and teacherRoom
          (_b =
            (_a = this.eventSubscribers) === null || _a === void 0
              ? void 0
              : _a.classroomEventHandler) === null || _b === void 0
            ? void 0
            : _b.onLeaveClass(internal_1.LeaveClassEventModel.fromAny({}));
        }
      });
      try {
        this.storage = storage;
        if (!this._classChannel) {
          this._classChannel = new internal_1.ClassChannel(
            this.socketController,
            internal_1.OrgVerificationController.getInstance(),
            new internal_1.OrgDataRetriever(),
            storage
          );
        }
        if (!this.limitingRequestHandler) {
          this.limitingRequestHandler = new internal_1.LimitingRequestHandler();
        }
        if (!this.conferenceController) {
          this.conferenceController =
            new internal_1.ConferenceControllerInterop(this.clientParams);
        }
        if (!this.meetingController) {
          this.meetingController = new internal_1.MeetingController(
            this.clientParams
          );
        }
        if (!this.statusControllerInterop) {
          this.statusControllerInterop = new internal_1.StatusControllerInterop(
            this
          );
        }
        // DJB - 2/24/2023 - See the note in MetricReporterConfig.getReportingInterval before
        // uncommenting this.

        new MetricReporter({
          apiServer: this.clientParams.apiServer,
          accumulator: MetricAccumulator.getInstance(),
          deviceId: this.clientParams.deviceId,
          provisioningCode: this.clientParams.provisioningCode,
        });
        this.isInitialized = true;
        resolve();
      } catch (err) {
        this.logger.logError("LSAClient init() exception: " + err);
        reject(err);
      }
    });
  }
  async connect() {
    var _a;
    if (!this.isInitialized) {
      const errStr = "LSAClient.connect(): Call .init(IStorage) first.";
      this.logger.logError(errStr);
      throw new Error(errStr);
    }
    if (this._knownClientStatus) {
      try {
        if (this._knownClientStatus.isProvisioningOK()) {
          pubsub_js_1.default.publish("onProvisionStatus", {
            provisioned: true,
          });
        }
      } catch (e) {
        this.logger.logError(
          "Error calling knownClientStatus.isProvisioningOK(): " + e
        );
      }
      try {
        if (this._knownClientStatus.isTokenStatusOK()) {
          pubsub_js_1.default.publish("onTokenStatus", {
            validToken: true,
          });
        }
      } catch (e) {
        this.logger.logError(
          "Error calling knownClientStatus.isTokenStatusOK(): " + e
        );
      }
    }
    // make sure we have default status
    (_a = this.statusControllerInterop) === null || _a === void 0
      ? void 0
      : _a.dispatchCurrentStatus();
    this.logger.logInfo("LSAClient.connect(+)");
    this.logger.logInfo("LSAClient.connect(): Waiting for onlineness...");
    await this.networkCallback.waitUntilDeviceIsOnline();
    this.logger.logInfo(
      "LSAClient.connect(): Device is online. Checking provisioning code..."
    );
    let isHotProvisioning = this.clientParams.hotProvisioningCode.length > 0;
    let exchangedCode;
    if (isHotProvisioning) {
      exchangedCode =
        await this.orgChecker.provisioningCodeFromHotProvisioningCode(
          this.clientParams
        );
      this.clientParams.provisioningCode = exchangedCode;
    }
    const validOrg = await this.orgChecker.isOrgValid(this.clientParams);
    if (!validOrg) {
      const errStr =
        "LSAClient.connect(): Org is invalid. params = " +
        JSON.stringify(this.clientParams);
      this.logger.logError(errStr);
      pubsub_js_1.default.publish("onProvisionStatus", {
        provisioned: false,
        error: {
          error:
            internal_1.i18nController.getMessage("org_invalid") ||
            "The specified organization could not be validated.",
        },
      });
      pubsub_js_1.default.publish("onAppHalt");
      try {
        await new internal_1.DeadOrgNotificationDialog(
          this,
          this.logger
        ).launch();
      } catch (e) {
        this.logger.logError("DeadOrgNotificationDialog threw exception: " + e);
      }
      throw new Error(errStr);
    }
    if (isHotProvisioning) {
      this.storage.saveProvisioningCode(exchangedCode);
      pubsub_js_1.default.subscribe("onProvisionStatus", (msg, data) => {
        if (data && data.provisioned && data.provisioned === true) {
          this.storage.saveHotProvisioningCode("");
        }
      });
    }
    if (this.storage.forceReprovision()) {
      internal_1.AccessToken.clearProvisioningPreferences();
      if (this._reprovisionActionHandler) {
        try {
          this._reprovisionActionHandler.onForceReprovisionActionStarted();
        } catch (e) {
          this.logger.logError("onForceReprovisionActionStarted error: " + e);
        }
      }
    }
    // Connect to the socket
    await this.socketController.startConnection();
  }
}
exports.LSAClient = LSAClient;
//# sourceMappingURL=lsaClient.js.map
