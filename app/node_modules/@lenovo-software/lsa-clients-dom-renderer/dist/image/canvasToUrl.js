"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasToUrlFactory = void 0;
const supportedImages_1 = require("./supportedImages");
class UrlFromOffscreenCanvas {
    constructor(logger, canvas) {
        this.logger = logger;
        this.canvas = canvas;
    }
    toUrl(params) {
        return new Promise(async (resolve, reject) => {
            this.logger.logDebug('UrlFromOffscreenCanvas.toUrl(): Converting to blob...');
            try {
                let finalBlob = await this.canvas.convertToBlob({
                    type: (params.format) ? supportedImages_1.ImageFormats.contentTypeFromFormat(params.format) : 'image/jpeg',
                    quality: (params.quality) ? params.quality / 100 : 0.91 // 91% appears to produce approx. the same size as what the current web helper produces
                });
                this.logger.logDebug('UrlFromOffscreenCanvas.toUrl(): Finished.');
                let reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.readAsDataURL(finalBlob);
            }
            catch (err) {
                reject('UrlFromOffscreenCanvas.toUrl(): Error converting into blob: ' + JSON.stringify(err));
            }
        });
    }
}
class UrlFromHTMLCanvas {
    constructor(logger, canvas) {
        this.logger = logger;
        this.canvas = canvas;
    }
    async toUrl(params) {
        var _a;
        this.logger.logDebug('UrlFromHTMLCanvas.toUrl(): toDataURL()...');
        const defaultFormat = 'jpeg';
        const format = supportedImages_1.ImageFormats.contentTypeFromFormat((_a = params === null || params === void 0 ? void 0 : params.format) !== null && _a !== void 0 ? _a : defaultFormat);
        const quality = (params === null || params === void 0 ? void 0 : params.quality) ? params.quality / 100 : 0.91; // 91% appears to produce approx. the same size as what the current web helper produces
        const dataUrl = this.canvas.toDataURL(format, quality);
        this.logger.logDebug('UrlFromHTMLCanvas.toUrl(): DONE');
        return Promise.resolve(dataUrl);
    }
}
class CanvasToUrlFactory {
    constructor() {
    }
    static getInstance(logger, canvas) {
        if (typeof HTMLCanvasElement !== 'undefined' &&
            canvas instanceof HTMLCanvasElement) {
            return new UrlFromHTMLCanvas(logger, canvas);
        }
        if (canvas instanceof OffscreenCanvas) {
            return new UrlFromOffscreenCanvas(logger, canvas);
        }
        throw new Error('CanvasToUrl.getInstance(): Unknown type.');
    }
}
exports.CanvasToUrlFactory = CanvasToUrlFactory;
//# sourceMappingURL=canvasToUrl.js.map