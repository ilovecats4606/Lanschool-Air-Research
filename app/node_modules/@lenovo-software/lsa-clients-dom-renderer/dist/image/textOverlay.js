"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextOverlay = void 0;
class TextOverlay {
    constructor(context, truncateMessage, devicePixelRatio) {
        this.truncateMessage = truncateMessage;
        this.devicePixelRatio = devicePixelRatio;
        this.context = context;
    }
    canvasTextOverlay(imageWidth, imageHeight, message) {
        let metrics;
        let boxWidth = 0;
        let boxHeight = 0;
        for (var font = 12; font < 144; font += 12) {
            // console.log("Trying font size " + font);
            this.context.font = font + "px Arial";
            metrics = this.context.measureText(message);
            boxWidth = metrics.width * this.devicePixelRatio + 20;
            boxHeight = font + 12;
            if (boxWidth / imageWidth > 0.33)
                break;
        }
        let centerline = imageWidth / 2;
        let boxStartX = centerline - boxWidth / 2;
        if (boxStartX < 0)
            boxStartX = 0;
        if (boxWidth > imageWidth)
            boxWidth = imageWidth;
        let formattedMessage = message;
        if (this.truncateMessage) {
            formattedMessage = this.getTruncatedTextForWidth(message, boxWidth, this.devicePixelRatio);
            if (formattedMessage === '...')
                return this.context;
        }
        this.context.globalAlpha = 0.5;
        this.context.fillStyle = "black";
        this.context.strokeStyle = "white";
        this.drawRoundedRect(boxStartX, 10, boxWidth, boxHeight, 5, true, true);
        this.context.globalAlpha = 1;
        this.context.fillStyle = "white";
        this.context.fillText(formattedMessage, boxStartX + 10, 10 + boxHeight - (0.25 * font), boxWidth);
        return this.context;
    }
    getTruncatedTextForWidth(textToShorten, fitWidth, devicePixelRatio) {
        let finalText = textToShorten;
        let textWidth = this.context.measureText(finalText).width * devicePixelRatio + 10;
        let n = textToShorten.length;
        while (textWidth > fitWidth && n > 0) {
            finalText = textToShorten.substr(0, --n) + "...";
            textWidth = this.context.measureText(finalText).width * devicePixelRatio + 10;
        }
        return finalText;
    }
    ;
    drawRoundedRect(x, y, width, height, radius, fill, stroke) {
        let radii = {
            tl: radius,
            tr: radius,
            br: radius,
            bl: radius
        };
        this.context.beginPath();
        this.context.moveTo(x + radii.tl, y);
        this.context.lineTo(x + width - radii.tr, y);
        this.context.quadraticCurveTo(x + width, y, x + width, y + radii.tr);
        this.context.lineTo(x + width, y + height - radii.br);
        this.context.quadraticCurveTo(x + width, y + height, x + width - radii.br, y + height);
        this.context.lineTo(x + radii.bl, y + height);
        this.context.quadraticCurveTo(x, y + height, x, y + height - radii.bl);
        this.context.lineTo(x, y + radii.tl);
        this.context.quadraticCurveTo(x, y, x + radii.tl, y);
        this.context.closePath();
        if (fill) {
            this.context.fill();
        }
        if (stroke) {
            this.context.stroke();
        }
    }
    canvasWrapText(x, y, width, height, lineHeight, message) {
        var words = message.split(' ');
        var line = '';
        for (var n = 0; n < words.length; n++) {
            var tline = line + words[n] + ' ';
            var metrics = this.context.measureText(tline);
            var twidth = metrics.width;
            if (twidth > width && n > 0) {
                this.context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = tline;
            }
        }
        this.context.fillText(line, x, y);
        return this.context;
    }
}
exports.TextOverlay = TextOverlay;
//# sourceMappingURL=textOverlay.js.map