"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
const textOverlay_1 = require("../textOverlay");
// Mock Logger
const loggerMocks = {
    getInstance: jest.fn(),
    log: jest.fn(),
    timeStampMS: jest.fn()
};
// Mock global.document
const documentMocks = {
    createElement: jest.fn(),
    addEventListener: jest.fn(),
    canvas: {
        getContext: jest.fn(),
        measureText: jest.fn(),
        fillText: jest.fn(),
        beginPath: jest.fn(),
        fill: jest.fn(),
        stroke: jest.fn(),
        moveTo: jest.fn(),
        lineTo: jest.fn(),
        quadraticCurveTo: jest.fn(),
        closePath: jest.fn()
    }
};
const mockedCanvasBuffer = 'canvas-base-64-image';
// Mock global.document
let originalDocument;
const mockedDocument = {
    createElement: (id) => {
        documentMocks.createElement(id);
        if (id === 'canvas') {
            return {
                width: 100,
                height: 100,
                toDataURL: (type) => {
                    return mockedCanvasBuffer;
                },
                getContext: (type) => {
                    documentMocks.canvas.getContext(type);
                    return {
                        imageSmoothingEnabled: true,
                        fillStyle: '#ffffff',
                        font: '10px',
                        fill: () => {
                            documentMocks.canvas.fill();
                            return;
                        },
                        fillText: (text, x, y, maxWidth) => {
                            documentMocks.canvas.fillText();
                        },
                        stroke: () => {
                            documentMocks.canvas.stroke();
                        },
                        measureText: (message) => {
                            documentMocks.canvas.measureText(message);
                            return {
                                width: 100
                            };
                        },
                        beginPath: () => {
                            documentMocks.canvas.beginPath();
                        },
                        moveTo: (x, y) => {
                            documentMocks.canvas.moveTo();
                        },
                        lineTo: (x, y) => {
                            documentMocks.canvas.lineTo();
                        },
                        quadraticCurveTo: (x, y, radius, radius2) => {
                            documentMocks.canvas.quadraticCurveTo();
                        },
                        closePath: () => {
                            documentMocks.canvas.closePath();
                        }
                    };
                }
            };
        }
        else {
            return {};
        }
    },
    addEventListener: (event, fn) => {
        documentMocks.addEventListener(event);
    }
};
beforeAll(() => {
    originalDocument = global.document;
    // Mock chrome.runtime
    Object.defineProperty(global, 'document', {
        value: mockedDocument
    });
});
describe('Full Screen Capture', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('Should call canvasTextOverlay and return the context object', async () => {
        const canvas = document.createElement('canvas');
        let context = canvas.getContext('2d');
        // @ts-ignore
        const textOverlay = new textOverlay_1.TextOverlay(context);
        // @ts-ignore
        context = textOverlay.canvasTextOverlay(100, 100, 'Test Message');
        expect(documentMocks.canvas.measureText).toHaveBeenCalledWith('Test Message');
        expect(documentMocks.canvas.fillText).toHaveBeenCalled();
        expect(documentMocks.canvas.beginPath).toHaveBeenCalled();
        expect(documentMocks.canvas.moveTo).toHaveBeenCalled();
        expect(documentMocks.canvas.lineTo).toHaveBeenCalled();
        expect(documentMocks.canvas.quadraticCurveTo).toHaveBeenCalled();
        expect(documentMocks.canvas.closePath).toHaveBeenCalled();
        expect(documentMocks.canvas.fill).toHaveBeenCalled();
        expect(documentMocks.canvas.stroke).toHaveBeenCalled();
    });
});
afterAll(() => {
    // Reset mocked global.document
    Object.defineProperty(global, 'document', {
        value: originalDocument
    });
});
//# sourceMappingURL=textOverlay.test.js.map