"use strict";
// Copyright Â© 2023 Lenovo. All rights reserved.
// Confidential and Restricted
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageProcessor = void 0;
const textOverlay_1 = require("./textOverlay");
const canvasToUrl_1 = require("./canvasToUrl");
class ImageProcessor {
    constructor(logger, _canvas) {
        this.logger = logger;
        this._canvas = _canvas;
        if (_canvas) {
            this.canvas = _canvas;
        }
        else {
            this.canvas = null;
        }
    }
    static calculateScale(width, height, newWidth, newHeight) {
        let scale = 1;
        let xscale = newWidth / width;
        let yscale = newHeight / height;
        if (xscale < yscale)
            scale = xscale;
        else
            scale = yscale;
        return scale;
    }
    async processImage(image, params) {
        this.logger.logInfo('ImageProcessor.processImage(+): params: ' + JSON.stringify(params));
        return new Promise(async (resolve, reject) => {
            if (!params) {
                params = {};
            }
            if (!params.width) {
                params.width = 480;
            }
            if (!params.height) {
                params.height = 240;
            }
            if (!this.canvas) {
                this.canvas = new OffscreenCanvas(params.width, params.height);
            }
            let context = this.canvas.getContext('2d');
            if (!context) {
                throw new Error('ThumbnailCapture.processThumbnail(): context is null');
            }
            let targetWidth = params.width;
            let targetHeight = params.height;
            const imgScalingReq = image.width !== targetWidth || image.height !== targetHeight;
            if (imgScalingReq && params.stretchToFit) {
                const scale = ImageProcessor.calculateScale(image.width, image.height, params.width, params.height);
                targetWidth = Math.round(image.width * scale);
                targetHeight = Math.round(image.height * scale);
            }
            // Set the dimensions of canvas equal to target image dimensions.
            this.canvas.width = targetWidth;
            this.canvas.height = targetHeight;
            context.fillStyle = "#000000";
            context.fillRect(0, 0, params.width, params.height);
            const drawPositionX = params.stretchToFit ? 0 : Math.round((params.width - targetWidth) / 2);
            const drawPositionY = params.stretchToFit ? 0 : Math.round((params.height - targetHeight) / 2);
            context.drawImage(image, drawPositionX, drawPositionY, targetWidth, targetHeight);
            if (params.overlayMessage && params.overlayMessage.length > 0) {
                context = new textOverlay_1.TextOverlay(context, params.truncateMessage || false, params.devicePixelRatio || 1).canvasTextOverlay(targetWidth, targetHeight, params.overlayMessage);
            }
            const urlString = await canvasToUrl_1.CanvasToUrlFactory.getInstance(this.logger, this.canvas).toUrl(params);
            resolve(urlString);
        });
    }
    blobFromWindow(byteStringArray, mime) {
        if (typeof window === 'undefined' || !window.atob) {
            return null;
        }
        let n = byteStringArray[1].length;
        let byteString = window.atob(byteStringArray[1]);
        let arrayBuffer = new Uint8Array(byteString.length);
        while (n--) {
            arrayBuffer[n] = byteString.charCodeAt(n);
        }
        return new Blob([arrayBuffer], { type: mime[1] });
    }
    toImageBitmap(dataURI) {
        const byteStringArray = dataURI.split(',');
        if (!byteStringArray || byteStringArray.length < 2) {
            throw new Error('ImageProcessor.toImageBitmap(): byteStringArray too small.');
        }
        const mime = byteStringArray[0].match(/:(.*?);/);
        if (!mime || mime.length < 2) {
            throw new Error('ImageProcessor.toImageBitmap(): Mime type not found.');
        }
        let blob = this.blobFromWindow(byteStringArray, mime);
        if (!blob) {
            throw new Error('ImageProcessor.toImageBitmap(): Could not create blob.');
        }
        return createImageBitmap(blob);
    }
}
exports.ImageProcessor = ImageProcessor;
//# sourceMappingURL=imageProcessor.js.map